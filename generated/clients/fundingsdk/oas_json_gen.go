// Code generated by ogen, DO NOT EDIT.

package fundingsdk

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AdminBankDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdminBankDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accountType")
		e.Str(s.AccountType)
	}
	{
		e.FieldStart("bankName")
		e.Str(s.BankName)
	}
	{
		if s.BankCode.Set {
			e.FieldStart("bankCode")
			s.BankCode.Encode(e)
		}
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("beneficiaryName")
		e.Str(s.BeneficiaryName)
	}
	{
		e.FieldStart("accountNumber")
		e.Str(s.AccountNumber)
	}
	{
		e.FieldStart("swift")
		e.Str(s.Swift)
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
}

var jsonFieldsNameOfAdminBankDto = [8]string{
	0: "accountType",
	1: "bankName",
	2: "bankCode",
	3: "currency",
	4: "beneficiaryName",
	5: "accountNumber",
	6: "swift",
	7: "country",
}

// Decode decodes AdminBankDto from json.
func (s *AdminBankDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdminBankDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccountType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountType\"")
			}
		case "bankName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BankName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankName\"")
			}
		case "bankCode":
			if err := func() error {
				s.BankCode.Reset()
				if err := s.BankCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankCode\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "beneficiaryName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BeneficiaryName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beneficiaryName\"")
			}
		case "accountNumber":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AccountNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountNumber\"")
			}
		case "swift":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Swift = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swift\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdminBankDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAdminBankDto) {
					name = jsonFieldsNameOfAdminBankDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdminBankDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdminBankDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnonymizePiiRequestDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnonymizePiiRequestDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("deletion_request_id")
		e.Str(s.DeletionRequestID)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfAnonymizePiiRequestDTO = [2]string{
	0: "deletion_request_id",
	1: "user",
}

// Decode decodes AnonymizePiiRequestDTO from json.
func (s *AnonymizePiiRequestDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnonymizePiiRequestDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deletion_request_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DeletionRequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletion_request_id\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnonymizePiiRequestDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnonymizePiiRequestDTO) {
					name = jsonFieldsNameOfAnonymizePiiRequestDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnonymizePiiRequestDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnonymizePiiRequestDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnonymizePiiRequestDTOUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnonymizePiiRequestDTOUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
	{
		e.FieldStart("customer_id")
		e.Str(s.CustomerID)
	}
	{
		e.FieldStart("account_id")
		e.Str(s.AccountID)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfAnonymizePiiRequestDTOUser = [4]string{
	0: "user_id",
	1: "customer_id",
	2: "account_id",
	3: "email",
}

// Decode decodes AnonymizePiiRequestDTOUser from json.
func (s *AnonymizePiiRequestDTOUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnonymizePiiRequestDTOUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "customer_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CustomerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customer_id\"")
			}
		case "account_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AccountID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnonymizePiiRequestDTOUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnonymizePiiRequestDTOUser) {
					name = jsonFieldsNameOfAnonymizePiiRequestDTOUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnonymizePiiRequestDTOUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnonymizePiiRequestDTOUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankAccountDestination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankAccountDestination) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("bankAccountNumber")
		e.Str(s.BankAccountNumber)
	}
	{
		if s.BankAccountHolder.Set {
			e.FieldStart("bankAccountHolder")
			s.BankAccountHolder.Encode(e)
		}
	}
	{
		if s.BankAccountHolderAccountId.Set {
			e.FieldStart("bankAccountHolderAccountId")
			s.BankAccountHolderAccountId.Encode(e)
		}
	}
	{
		if s.BankName.Set {
			e.FieldStart("bankName")
			s.BankName.Encode(e)
		}
	}
	{
		if s.BankSwiftCode.Set {
			e.FieldStart("bankSwiftCode")
			s.BankSwiftCode.Encode(e)
		}
	}
	{
		if s.BankAccountType.Set {
			e.FieldStart("bankAccountType")
			s.BankAccountType.Encode(e)
		}
	}
}

var jsonFieldsNameOfBankAccountDestination = [7]string{
	0: "currency",
	1: "bankAccountNumber",
	2: "bankAccountHolder",
	3: "bankAccountHolderAccountId",
	4: "bankName",
	5: "bankSwiftCode",
	6: "bankAccountType",
}

// Decode decodes BankAccountDestination from json.
func (s *BankAccountDestination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankAccountDestination to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "bankAccountNumber":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BankAccountNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankAccountNumber\"")
			}
		case "bankAccountHolder":
			if err := func() error {
				s.BankAccountHolder.Reset()
				if err := s.BankAccountHolder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankAccountHolder\"")
			}
		case "bankAccountHolderAccountId":
			if err := func() error {
				s.BankAccountHolderAccountId.Reset()
				if err := s.BankAccountHolderAccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankAccountHolderAccountId\"")
			}
		case "bankName":
			if err := func() error {
				s.BankName.Reset()
				if err := s.BankName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankName\"")
			}
		case "bankSwiftCode":
			if err := func() error {
				s.BankSwiftCode.Reset()
				if err := s.BankSwiftCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankSwiftCode\"")
			}
		case "bankAccountType":
			if err := func() error {
				s.BankAccountType.Reset()
				if err := s.BankAccountType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankAccountType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankAccountDestination")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankAccountDestination) {
					name = jsonFieldsNameOfBankAccountDestination[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankAccountDestination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankAccountDestination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BankAccountSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BankAccountSource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bankAccountNumber")
		e.Str(s.BankAccountNumber)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		if s.AccountHolder.Set {
			e.FieldStart("accountHolder")
			s.AccountHolder.Encode(e)
		}
	}
	{
		if s.BankName.Set {
			e.FieldStart("bankName")
			s.BankName.Encode(e)
		}
	}
	{
		if s.BankAccountType.Set {
			e.FieldStart("bankAccountType")
			s.BankAccountType.Encode(e)
		}
	}
}

var jsonFieldsNameOfBankAccountSource = [5]string{
	0: "bankAccountNumber",
	1: "currency",
	2: "accountHolder",
	3: "bankName",
	4: "bankAccountType",
}

// Decode decodes BankAccountSource from json.
func (s *BankAccountSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BankAccountSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bankAccountNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BankAccountNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankAccountNumber\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "accountHolder":
			if err := func() error {
				s.AccountHolder.Reset()
				if err := s.AccountHolder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountHolder\"")
			}
		case "bankName":
			if err := func() error {
				s.BankName.Reset()
				if err := s.BankName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankName\"")
			}
		case "bankAccountType":
			if err := func() error {
				s.BankAccountType.Reset()
				if err := s.BankAccountType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankAccountType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BankAccountSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBankAccountSource) {
					name = jsonFieldsNameOfBankAccountSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BankAccountSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BankAccountSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BanksConnectStatusResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BanksConnectStatusResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfBanksConnectStatusResponseDto = [1]string{
	0: "status",
}

// Decode decodes BanksConnectStatusResponseDto from json.
func (s *BanksConnectStatusResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BanksConnectStatusResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BanksConnectStatusResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBanksConnectStatusResponseDto) {
					name = jsonFieldsNameOfBanksConnectStatusResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BanksConnectStatusResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BanksConnectStatusResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BanksConnectStatusResponseDtoStatus as json.
func (s BanksConnectStatusResponseDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BanksConnectStatusResponseDtoStatus from json.
func (s *BanksConnectStatusResponseDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BanksConnectStatusResponseDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BanksConnectStatusResponseDtoStatus(v) {
	case BanksConnectStatusResponseDtoStatusBANKCREATED:
		*s = BanksConnectStatusResponseDtoStatusBANKCREATED
	case BanksConnectStatusResponseDtoStatusNOBANKFOUND:
		*s = BanksConnectStatusResponseDtoStatusNOBANKFOUND
	default:
		*s = BanksConnectStatusResponseDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BanksConnectStatusResponseDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BanksConnectStatusResponseDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchWithdrawalApprovalInputDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchWithdrawalApprovalInputDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("withdrawalIds")
		e.ArrStart()
		for _, elem := range s.WithdrawalIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("thresholdAmendments")
		e.ArrStart()
		for _, elem := range s.ThresholdAmendments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("justification")
		e.Str(s.Justification)
	}
	{
		e.FieldStart("approvedBy")
		e.Str(s.ApprovedBy)
	}
}

var jsonFieldsNameOfBatchWithdrawalApprovalInputDto = [5]string{
	0: "accountUuid",
	1: "withdrawalIds",
	2: "thresholdAmendments",
	3: "justification",
	4: "approvedBy",
}

// Decode decodes BatchWithdrawalApprovalInputDto from json.
func (s *BatchWithdrawalApprovalInputDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchWithdrawalApprovalInputDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "withdrawalIds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.WithdrawalIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WithdrawalIds = append(s.WithdrawalIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalIds\"")
			}
		case "thresholdAmendments":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.ThresholdAmendments = make([]ThresholdAmendmentDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ThresholdAmendmentDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ThresholdAmendments = append(s.ThresholdAmendments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thresholdAmendments\"")
			}
		case "justification":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Justification = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"justification\"")
			}
		case "approvedBy":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ApprovedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approvedBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchWithdrawalApprovalInputDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchWithdrawalApprovalInputDto) {
					name = jsonFieldsNameOfBatchWithdrawalApprovalInputDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchWithdrawalApprovalInputDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchWithdrawalApprovalInputDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchWithdrawalApprovalResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchWithdrawalApprovalResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("result")
		e.Str(s.Result)
	}
	{
		e.FieldStart("withdrawalIds")
		e.ArrStart()
		for _, elem := range s.WithdrawalIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBatchWithdrawalApprovalResponseDto = [2]string{
	0: "result",
	1: "withdrawalIds",
}

// Decode decodes BatchWithdrawalApprovalResponseDto from json.
func (s *BatchWithdrawalApprovalResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchWithdrawalApprovalResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "result":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Result = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "withdrawalIds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.WithdrawalIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WithdrawalIds = append(s.WithdrawalIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchWithdrawalApprovalResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchWithdrawalApprovalResponseDto) {
					name = jsonFieldsNameOfBatchWithdrawalApprovalResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchWithdrawalApprovalResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchWithdrawalApprovalResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CancellationCallbackDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CancellationCallbackDto) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCancellationCallbackDto = [0]string{}

// Decode decodes CancellationCallbackDto from json.
func (s *CancellationCallbackDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CancellationCallbackDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CancellationCallbackDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CancellationCallbackDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CancellationCallbackDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDdCustomerBankDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDdCustomerBankDto) encodeFields(e *jx.Encoder) {
	{
		if s.IsSetupFailed.Set {
			e.FieldStart("isSetupFailed")
			s.IsSetupFailed.Encode(e)
		}
	}
	{
		if s.ApplicantIDHash.Set {
			e.FieldStart("applicantIDHash")
			s.ApplicantIDHash.Encode(e)
		}
	}
	{
		if s.ApplicantIDType.Set {
			e.FieldStart("applicantIDType")
			s.ApplicantIDType.Encode(e)
		}
	}
	{
		if s.ExpectedApplicantIDType.Set {
			e.FieldStart("expectedApplicantIDType")
			s.ExpectedApplicantIDType.Encode(e)
		}
	}
	{
		if s.FailedVerificationReason.Set {
			e.FieldStart("failedVerificationReason")
			s.FailedVerificationReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDdCustomerBankDto = [5]string{
	0: "isSetupFailed",
	1: "applicantIDHash",
	2: "applicantIDType",
	3: "expectedApplicantIDType",
	4: "failedVerificationReason",
}

// Decode decodes CreateDdCustomerBankDto from json.
func (s *CreateDdCustomerBankDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDdCustomerBankDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isSetupFailed":
			if err := func() error {
				s.IsSetupFailed.Reset()
				if err := s.IsSetupFailed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSetupFailed\"")
			}
		case "applicantIDHash":
			if err := func() error {
				s.ApplicantIDHash.Reset()
				if err := s.ApplicantIDHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applicantIDHash\"")
			}
		case "applicantIDType":
			if err := func() error {
				s.ApplicantIDType.Reset()
				if err := s.ApplicantIDType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"applicantIDType\"")
			}
		case "expectedApplicantIDType":
			if err := func() error {
				s.ExpectedApplicantIDType.Reset()
				if err := s.ExpectedApplicantIDType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expectedApplicantIDType\"")
			}
		case "failedVerificationReason":
			if err := func() error {
				s.FailedVerificationReason.Reset()
				if err := s.FailedVerificationReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedVerificationReason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDdCustomerBankDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDdCustomerBankDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDdCustomerBankDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDepositScheduleDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDepositScheduleDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("portfolioUuid")
		e.Str(s.PortfolioUuid)
	}
	{
		e.FieldStart("customerBankUuid")
		e.Str(s.CustomerBankUuid)
	}
	{
		e.FieldStart("requestType")
		s.RequestType.Encode(e)
	}
	{
		e.FieldStart("scheduleType")
		s.ScheduleType.Encode(e)
	}
	{
		if s.Frequency.Set {
			e.FieldStart("frequency")
			s.Frequency.Encode(e)
		}
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		if s.PersistentUuid.Set {
			e.FieldStart("persistentUuid")
			s.PersistentUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDepositScheduleDto = [10]string{
	0: "accountUuid",
	1: "portfolioUuid",
	2: "customerBankUuid",
	3: "requestType",
	4: "scheduleType",
	5: "frequency",
	6: "amount",
	7: "currency",
	8: "startDate",
	9: "persistentUuid",
}

// Decode decodes CreateDepositScheduleDto from json.
func (s *CreateDepositScheduleDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDepositScheduleDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "portfolioUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portfolioUuid\"")
			}
		case "customerBankUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CustomerBankUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankUuid\"")
			}
		case "requestType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RequestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestType\"")
			}
		case "scheduleType":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ScheduleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduleType\"")
			}
		case "frequency":
			if err := func() error {
				s.Frequency.Reset()
				if err := s.Frequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "startDate":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "persistentUuid":
			if err := func() error {
				s.PersistentUuid.Reset()
				if err := s.PersistentUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDepositScheduleDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11011111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDepositScheduleDto) {
					name = jsonFieldsNameOfCreateDepositScheduleDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDepositScheduleDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDepositScheduleDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDepositScheduleDtoFrequency as json.
func (s CreateDepositScheduleDtoFrequency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDepositScheduleDtoFrequency from json.
func (s *CreateDepositScheduleDtoFrequency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDepositScheduleDtoFrequency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDepositScheduleDtoFrequency(v) {
	case CreateDepositScheduleDtoFrequencyDAILY:
		*s = CreateDepositScheduleDtoFrequencyDAILY
	case CreateDepositScheduleDtoFrequencyWEEKLY:
		*s = CreateDepositScheduleDtoFrequencyWEEKLY
	case CreateDepositScheduleDtoFrequencyBIWEEKLY:
		*s = CreateDepositScheduleDtoFrequencyBIWEEKLY
	case CreateDepositScheduleDtoFrequencyMONTHLY:
		*s = CreateDepositScheduleDtoFrequencyMONTHLY
	case CreateDepositScheduleDtoFrequencyQUARTERLY:
		*s = CreateDepositScheduleDtoFrequencyQUARTERLY
	case CreateDepositScheduleDtoFrequencySEMIANNUALLY:
		*s = CreateDepositScheduleDtoFrequencySEMIANNUALLY
	case CreateDepositScheduleDtoFrequencyANNUALLY:
		*s = CreateDepositScheduleDtoFrequencyANNUALLY
	default:
		*s = CreateDepositScheduleDtoFrequency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDepositScheduleDtoFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDepositScheduleDtoFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDepositScheduleDtoRequestType as json.
func (s CreateDepositScheduleDtoRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDepositScheduleDtoRequestType from json.
func (s *CreateDepositScheduleDtoRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDepositScheduleDtoRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDepositScheduleDtoRequestType(v) {
	case CreateDepositScheduleDtoRequestTypeSRS:
		*s = CreateDepositScheduleDtoRequestTypeSRS
	case CreateDepositScheduleDtoRequestTypeDIRECTDEBIT:
		*s = CreateDepositScheduleDtoRequestTypeDIRECTDEBIT
	case CreateDepositScheduleDtoRequestTypeFAST:
		*s = CreateDepositScheduleDtoRequestTypeFAST
	case CreateDepositScheduleDtoRequestTypeLEAN:
		*s = CreateDepositScheduleDtoRequestTypeLEAN
	default:
		*s = CreateDepositScheduleDtoRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDepositScheduleDtoRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDepositScheduleDtoRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDepositScheduleDtoScheduleType as json.
func (s CreateDepositScheduleDtoScheduleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDepositScheduleDtoScheduleType from json.
func (s *CreateDepositScheduleDtoScheduleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDepositScheduleDtoScheduleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDepositScheduleDtoScheduleType(v) {
	case CreateDepositScheduleDtoScheduleTypeONETIME:
		*s = CreateDepositScheduleDtoScheduleTypeONETIME
	case CreateDepositScheduleDtoScheduleTypeRECURRING:
		*s = CreateDepositScheduleDtoScheduleTypeRECURRING
	case CreateDepositScheduleDtoScheduleTypeINSTANT:
		*s = CreateDepositScheduleDtoScheduleTypeINSTANT
	default:
		*s = CreateDepositScheduleDtoScheduleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDepositScheduleDtoScheduleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDepositScheduleDtoScheduleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDepositScheduleRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDepositScheduleRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("portfolioUuid")
		e.Str(s.PortfolioUuid)
	}
	{
		e.FieldStart("customerBankUuid")
		e.Str(s.CustomerBankUuid)
	}
	{
		e.FieldStart("requestType")
		s.RequestType.Encode(e)
	}
	{
		e.FieldStart("scheduleType")
		s.ScheduleType.Encode(e)
	}
	{
		if s.Frequency.Set {
			e.FieldStart("frequency")
			s.Frequency.Encode(e)
		}
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		if s.PersistentUuid.Set {
			e.FieldStart("persistentUuid")
			s.PersistentUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDepositScheduleRequestDto = [9]string{
	0: "portfolioUuid",
	1: "customerBankUuid",
	2: "requestType",
	3: "scheduleType",
	4: "frequency",
	5: "amount",
	6: "currency",
	7: "startDate",
	8: "persistentUuid",
}

// Decode decodes CreateDepositScheduleRequestDto from json.
func (s *CreateDepositScheduleRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDepositScheduleRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "portfolioUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portfolioUuid\"")
			}
		case "customerBankUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CustomerBankUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankUuid\"")
			}
		case "requestType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RequestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestType\"")
			}
		case "scheduleType":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ScheduleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduleType\"")
			}
		case "frequency":
			if err := func() error {
				s.Frequency.Reset()
				if err := s.Frequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "startDate":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "persistentUuid":
			if err := func() error {
				s.PersistentUuid.Reset()
				if err := s.PersistentUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDepositScheduleRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDepositScheduleRequestDto) {
					name = jsonFieldsNameOfCreateDepositScheduleRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDepositScheduleRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDepositScheduleRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDepositScheduleRequestDtoFrequency as json.
func (s CreateDepositScheduleRequestDtoFrequency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDepositScheduleRequestDtoFrequency from json.
func (s *CreateDepositScheduleRequestDtoFrequency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDepositScheduleRequestDtoFrequency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDepositScheduleRequestDtoFrequency(v) {
	case CreateDepositScheduleRequestDtoFrequencyDAILY:
		*s = CreateDepositScheduleRequestDtoFrequencyDAILY
	case CreateDepositScheduleRequestDtoFrequencyWEEKLY:
		*s = CreateDepositScheduleRequestDtoFrequencyWEEKLY
	case CreateDepositScheduleRequestDtoFrequencyBIWEEKLY:
		*s = CreateDepositScheduleRequestDtoFrequencyBIWEEKLY
	case CreateDepositScheduleRequestDtoFrequencyMONTHLY:
		*s = CreateDepositScheduleRequestDtoFrequencyMONTHLY
	case CreateDepositScheduleRequestDtoFrequencyQUARTERLY:
		*s = CreateDepositScheduleRequestDtoFrequencyQUARTERLY
	case CreateDepositScheduleRequestDtoFrequencySEMIANNUALLY:
		*s = CreateDepositScheduleRequestDtoFrequencySEMIANNUALLY
	case CreateDepositScheduleRequestDtoFrequencyANNUALLY:
		*s = CreateDepositScheduleRequestDtoFrequencyANNUALLY
	default:
		*s = CreateDepositScheduleRequestDtoFrequency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDepositScheduleRequestDtoFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDepositScheduleRequestDtoFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDepositScheduleRequestDtoRequestType as json.
func (s CreateDepositScheduleRequestDtoRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDepositScheduleRequestDtoRequestType from json.
func (s *CreateDepositScheduleRequestDtoRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDepositScheduleRequestDtoRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDepositScheduleRequestDtoRequestType(v) {
	case CreateDepositScheduleRequestDtoRequestTypeSRS:
		*s = CreateDepositScheduleRequestDtoRequestTypeSRS
	case CreateDepositScheduleRequestDtoRequestTypeDIRECTDEBIT:
		*s = CreateDepositScheduleRequestDtoRequestTypeDIRECTDEBIT
	case CreateDepositScheduleRequestDtoRequestTypeFAST:
		*s = CreateDepositScheduleRequestDtoRequestTypeFAST
	case CreateDepositScheduleRequestDtoRequestTypeLEAN:
		*s = CreateDepositScheduleRequestDtoRequestTypeLEAN
	default:
		*s = CreateDepositScheduleRequestDtoRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDepositScheduleRequestDtoRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDepositScheduleRequestDtoRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDepositScheduleRequestDtoScheduleType as json.
func (s CreateDepositScheduleRequestDtoScheduleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDepositScheduleRequestDtoScheduleType from json.
func (s *CreateDepositScheduleRequestDtoScheduleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDepositScheduleRequestDtoScheduleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDepositScheduleRequestDtoScheduleType(v) {
	case CreateDepositScheduleRequestDtoScheduleTypeONETIME:
		*s = CreateDepositScheduleRequestDtoScheduleTypeONETIME
	case CreateDepositScheduleRequestDtoScheduleTypeRECURRING:
		*s = CreateDepositScheduleRequestDtoScheduleTypeRECURRING
	case CreateDepositScheduleRequestDtoScheduleTypeINSTANT:
		*s = CreateDepositScheduleRequestDtoScheduleTypeINSTANT
	default:
		*s = CreateDepositScheduleRequestDtoScheduleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDepositScheduleRequestDtoScheduleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDepositScheduleRequestDtoScheduleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateWhitelistedCustomerBankRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateWhitelistedCustomerBankRequestDto) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateWhitelistedCustomerBankRequestDto = [0]string{}

// Decode decodes CreateWhitelistedCustomerBankRequestDto from json.
func (s *CreateWhitelistedCustomerBankRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWhitelistedCustomerBankRequestDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateWhitelistedCustomerBankRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWhitelistedCustomerBankRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWhitelistedCustomerBankRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CustomerBankDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CustomerBankDto) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCustomerBankDto = [0]string{}

// Decode decodes CustomerBankDto from json.
func (s *CustomerBankDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomerBankDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CustomerBankDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CustomerBankDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomerBankDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepositRecordsInternalControllerGetDepositRecordsReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepositRecordsInternalControllerGetDepositRecordsReq) encodeFields(e *jx.Encoder) {
	{
		if s.DepositIds != nil {
			e.FieldStart("depositIds")
			e.ArrStart()
			for _, elem := range s.DepositIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDepositRecordsInternalControllerGetDepositRecordsReq = [1]string{
	0: "depositIds",
}

// Decode decodes DepositRecordsInternalControllerGetDepositRecordsReq from json.
func (s *DepositRecordsInternalControllerGetDepositRecordsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositRecordsInternalControllerGetDepositRecordsReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "depositIds":
			if err := func() error {
				s.DepositIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DepositIds = append(s.DepositIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepositRecordsInternalControllerGetDepositRecordsReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepositRecordsInternalControllerGetDepositRecordsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositRecordsInternalControllerGetDepositRecordsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepositScheduleDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepositScheduleDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		e.Str(s.UUID)
	}
	{
		e.FieldStart("persistentUuid")
		e.Str(s.PersistentUuid)
	}
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("portfolioUuid")
		e.Str(s.PortfolioUuid)
	}
	{
		e.FieldStart("customerBankUuid")
		e.Str(s.CustomerBankUuid)
	}
	{
		e.FieldStart("requestType")
		s.RequestType.Encode(e)
	}
	{
		e.FieldStart("scheduleType")
		s.ScheduleType.Encode(e)
	}
	{
		if s.Frequency.Set {
			e.FieldStart("frequency")
			s.Frequency.Encode(e)
		}
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfDepositScheduleDto = [12]string{
	0:  "uuid",
	1:  "persistentUuid",
	2:  "accountUuid",
	3:  "portfolioUuid",
	4:  "customerBankUuid",
	5:  "requestType",
	6:  "scheduleType",
	7:  "frequency",
	8:  "amount",
	9:  "currency",
	10: "startDate",
	11: "status",
}

// Decode decodes DepositScheduleDto from json.
func (s *DepositScheduleDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "persistentUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PersistentUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentUuid\"")
			}
		case "accountUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "portfolioUuid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portfolioUuid\"")
			}
		case "customerBankUuid":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CustomerBankUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankUuid\"")
			}
		case "requestType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.RequestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestType\"")
			}
		case "scheduleType":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ScheduleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduleType\"")
			}
		case "frequency":
			if err := func() error {
				s.Frequency.Reset()
				if err := s.Frequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency\"")
			}
		case "amount":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "currency":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "startDate":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepositScheduleDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDepositScheduleDto) {
					name = jsonFieldsNameOfDepositScheduleDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepositScheduleDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleDtoFrequency as json.
func (s DepositScheduleDtoFrequency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DepositScheduleDtoFrequency from json.
func (s *DepositScheduleDtoFrequency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleDtoFrequency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DepositScheduleDtoFrequency(v) {
	case DepositScheduleDtoFrequencyDAILY:
		*s = DepositScheduleDtoFrequencyDAILY
	case DepositScheduleDtoFrequencyWEEKLY:
		*s = DepositScheduleDtoFrequencyWEEKLY
	case DepositScheduleDtoFrequencyBIWEEKLY:
		*s = DepositScheduleDtoFrequencyBIWEEKLY
	case DepositScheduleDtoFrequencyMONTHLY:
		*s = DepositScheduleDtoFrequencyMONTHLY
	case DepositScheduleDtoFrequencyQUARTERLY:
		*s = DepositScheduleDtoFrequencyQUARTERLY
	case DepositScheduleDtoFrequencySEMIANNUALLY:
		*s = DepositScheduleDtoFrequencySEMIANNUALLY
	case DepositScheduleDtoFrequencyANNUALLY:
		*s = DepositScheduleDtoFrequencyANNUALLY
	default:
		*s = DepositScheduleDtoFrequency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DepositScheduleDtoFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleDtoFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleDtoRequestType as json.
func (s DepositScheduleDtoRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DepositScheduleDtoRequestType from json.
func (s *DepositScheduleDtoRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleDtoRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DepositScheduleDtoRequestType(v) {
	case DepositScheduleDtoRequestTypeSRS:
		*s = DepositScheduleDtoRequestTypeSRS
	case DepositScheduleDtoRequestTypeDIRECTDEBIT:
		*s = DepositScheduleDtoRequestTypeDIRECTDEBIT
	case DepositScheduleDtoRequestTypeFAST:
		*s = DepositScheduleDtoRequestTypeFAST
	case DepositScheduleDtoRequestTypeLEAN:
		*s = DepositScheduleDtoRequestTypeLEAN
	default:
		*s = DepositScheduleDtoRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DepositScheduleDtoRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleDtoRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleDtoScheduleType as json.
func (s DepositScheduleDtoScheduleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DepositScheduleDtoScheduleType from json.
func (s *DepositScheduleDtoScheduleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleDtoScheduleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DepositScheduleDtoScheduleType(v) {
	case DepositScheduleDtoScheduleTypeONETIME:
		*s = DepositScheduleDtoScheduleTypeONETIME
	case DepositScheduleDtoScheduleTypeRECURRING:
		*s = DepositScheduleDtoScheduleTypeRECURRING
	case DepositScheduleDtoScheduleTypeINSTANT:
		*s = DepositScheduleDtoScheduleTypeINSTANT
	default:
		*s = DepositScheduleDtoScheduleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DepositScheduleDtoScheduleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleDtoScheduleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleDtoStatus as json.
func (s DepositScheduleDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DepositScheduleDtoStatus from json.
func (s *DepositScheduleDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DepositScheduleDtoStatus(v) {
	case DepositScheduleDtoStatusACTIVE:
		*s = DepositScheduleDtoStatusACTIVE
	case DepositScheduleDtoStatusINPROGRESS:
		*s = DepositScheduleDtoStatusINPROGRESS
	case DepositScheduleDtoStatusINACTIVE:
		*s = DepositScheduleDtoStatusINACTIVE
	default:
		*s = DepositScheduleDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DepositScheduleDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DepositScheduleView) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DepositScheduleView) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		e.Str(s.UUID)
	}
	{
		e.FieldStart("persistentUuid")
		e.Str(s.PersistentUuid)
	}
	{
		if s.LegacyId.Set {
			e.FieldStart("legacyId")
			s.LegacyId.Encode(e)
		}
	}
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("portfolioUuid")
		e.Str(s.PortfolioUuid)
	}
	{
		e.FieldStart("customerBankUuid")
		e.Str(s.CustomerBankUuid)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("scheduleType")
		s.ScheduleType.Encode(e)
	}
	{
		if s.Frequency.Set {
			e.FieldStart("frequency")
			s.Frequency.Encode(e)
		}
	}
	{
		e.FieldStart("requestType")
		s.RequestType.Encode(e)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("startDate")
		json.EncodeDateTime(e, s.StartDate)
	}
	{
		e.FieldStart("nextDate")
		e.Str(s.NextDate)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		if s.DeletedDate.Set {
			e.FieldStart("deletedDate")
			s.DeletedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DeletedBy.Set {
			e.FieldStart("deletedBy")
			s.DeletedBy.Encode(e)
		}
	}
	{
		e.FieldStart("pendingApproval")
		e.Bool(s.PendingApproval)
	}
}

var jsonFieldsNameOfDepositScheduleView = [19]string{
	0:  "uuid",
	1:  "persistentUuid",
	2:  "legacyId",
	3:  "accountUuid",
	4:  "portfolioUuid",
	5:  "customerBankUuid",
	6:  "status",
	7:  "scheduleType",
	8:  "frequency",
	9:  "requestType",
	10: "amount",
	11: "currency",
	12: "startDate",
	13: "nextDate",
	14: "createdAt",
	15: "updatedAt",
	16: "deletedDate",
	17: "deletedBy",
	18: "pendingApproval",
}

// Decode decodes DepositScheduleView from json.
func (s *DepositScheduleView) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleView to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "persistentUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PersistentUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentUuid\"")
			}
		case "legacyId":
			if err := func() error {
				s.LegacyId.Reset()
				if err := s.LegacyId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legacyId\"")
			}
		case "accountUuid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "portfolioUuid":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portfolioUuid\"")
			}
		case "customerBankUuid":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CustomerBankUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankUuid\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "scheduleType":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.ScheduleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduleType\"")
			}
		case "frequency":
			if err := func() error {
				s.Frequency.Reset()
				if err := s.Frequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency\"")
			}
		case "requestType":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.RequestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestType\"")
			}
		case "amount":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "currency":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "startDate":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startDate\"")
			}
		case "nextDate":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NextDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextDate\"")
			}
		case "createdAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "deletedDate":
			if err := func() error {
				s.DeletedDate.Reset()
				if err := s.DeletedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedDate\"")
			}
		case "deletedBy":
			if err := func() error {
				s.DeletedBy.Reset()
				if err := s.DeletedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedBy\"")
			}
		case "pendingApproval":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.PendingApproval = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pendingApproval\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DepositScheduleView")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111011,
		0b11111110,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDepositScheduleView) {
					name = jsonFieldsNameOfDepositScheduleView[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DepositScheduleView) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleView) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleViewFrequency as json.
func (s DepositScheduleViewFrequency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DepositScheduleViewFrequency from json.
func (s *DepositScheduleViewFrequency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleViewFrequency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DepositScheduleViewFrequency(v) {
	case DepositScheduleViewFrequencyDAILY:
		*s = DepositScheduleViewFrequencyDAILY
	case DepositScheduleViewFrequencyWEEKLY:
		*s = DepositScheduleViewFrequencyWEEKLY
	case DepositScheduleViewFrequencyBIWEEKLY:
		*s = DepositScheduleViewFrequencyBIWEEKLY
	case DepositScheduleViewFrequencyMONTHLY:
		*s = DepositScheduleViewFrequencyMONTHLY
	case DepositScheduleViewFrequencyQUARTERLY:
		*s = DepositScheduleViewFrequencyQUARTERLY
	case DepositScheduleViewFrequencySEMIANNUALLY:
		*s = DepositScheduleViewFrequencySEMIANNUALLY
	case DepositScheduleViewFrequencyANNUALLY:
		*s = DepositScheduleViewFrequencyANNUALLY
	default:
		*s = DepositScheduleViewFrequency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DepositScheduleViewFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleViewFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleViewRequestType as json.
func (s DepositScheduleViewRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DepositScheduleViewRequestType from json.
func (s *DepositScheduleViewRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleViewRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DepositScheduleViewRequestType(v) {
	case DepositScheduleViewRequestTypeSRS:
		*s = DepositScheduleViewRequestTypeSRS
	case DepositScheduleViewRequestTypeDIRECTDEBIT:
		*s = DepositScheduleViewRequestTypeDIRECTDEBIT
	case DepositScheduleViewRequestTypeFAST:
		*s = DepositScheduleViewRequestTypeFAST
	case DepositScheduleViewRequestTypeLEAN:
		*s = DepositScheduleViewRequestTypeLEAN
	default:
		*s = DepositScheduleViewRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DepositScheduleViewRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleViewRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleViewScheduleType as json.
func (s DepositScheduleViewScheduleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DepositScheduleViewScheduleType from json.
func (s *DepositScheduleViewScheduleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleViewScheduleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DepositScheduleViewScheduleType(v) {
	case DepositScheduleViewScheduleTypeONETIME:
		*s = DepositScheduleViewScheduleTypeONETIME
	case DepositScheduleViewScheduleTypeRECURRING:
		*s = DepositScheduleViewScheduleTypeRECURRING
	case DepositScheduleViewScheduleTypeINSTANT:
		*s = DepositScheduleViewScheduleTypeINSTANT
	default:
		*s = DepositScheduleViewScheduleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DepositScheduleViewScheduleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleViewScheduleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleViewStatus as json.
func (s DepositScheduleViewStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DepositScheduleViewStatus from json.
func (s *DepositScheduleViewStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DepositScheduleViewStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DepositScheduleViewStatus(v) {
	case DepositScheduleViewStatusACTIVE:
		*s = DepositScheduleViewStatusACTIVE
	case DepositScheduleViewStatusINPROGRESS:
		*s = DepositScheduleViewStatusINPROGRESS
	case DepositScheduleViewStatusINACTIVE:
		*s = DepositScheduleViewStatusINACTIVE
	default:
		*s = DepositScheduleViewStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DepositScheduleViewStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DepositScheduleViewStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSubmitWithdrawalRequestsInputDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSubmitWithdrawalRequestsInputDto) encodeFields(e *jx.Encoder) {
	{
		if s.RequestId.Set {
			e.FieldStart("requestId")
			s.RequestId.Encode(e)
		}
	}
	{
		e.FieldStart("customerBankId")
		e.Str(s.CustomerBankId)
	}
	{
		if s.WithdrawalCurrency.Set {
			e.FieldStart("withdrawalCurrency")
			s.WithdrawalCurrency.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Comment != nil {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
	{
		e.FieldStart("withdrawals")
		e.ArrStart()
		for _, elem := range s.Withdrawals {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfExternalSubmitWithdrawalRequestsInputDto = [6]string{
	0: "requestId",
	1: "customerBankId",
	2: "withdrawalCurrency",
	3: "reason",
	4: "comment",
	5: "withdrawals",
}

// Decode decodes ExternalSubmitWithdrawalRequestsInputDto from json.
func (s *ExternalSubmitWithdrawalRequestsInputDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSubmitWithdrawalRequestsInputDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requestId":
			if err := func() error {
				s.RequestId.Reset()
				if err := s.RequestId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		case "customerBankId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CustomerBankId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankId\"")
			}
		case "withdrawalCurrency":
			if err := func() error {
				s.WithdrawalCurrency.Reset()
				if err := s.WithdrawalCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalCurrency\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "comment":
			if err := func() error {
				s.Comment = nil
				var elem ExternalSubmitWithdrawalRequestsInputDtoComment
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Comment = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "withdrawals":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Withdrawals = make([]WithdrawalRequestDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WithdrawalRequestDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Withdrawals = append(s.Withdrawals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawals\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSubmitWithdrawalRequestsInputDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExternalSubmitWithdrawalRequestsInputDto) {
					name = jsonFieldsNameOfExternalSubmitWithdrawalRequestsInputDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSubmitWithdrawalRequestsInputDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSubmitWithdrawalRequestsInputDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSubmitWithdrawalRequestsInputDtoComment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSubmitWithdrawalRequestsInputDtoComment) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExternalSubmitWithdrawalRequestsInputDtoComment = [0]string{}

// Decode decodes ExternalSubmitWithdrawalRequestsInputDtoComment from json.
func (s *ExternalSubmitWithdrawalRequestsInputDtoComment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSubmitWithdrawalRequestsInputDtoComment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSubmitWithdrawalRequestsInputDtoComment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSubmitWithdrawalRequestsInputDtoComment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSubmitWithdrawalRequestsInputDtoComment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FailedDepositSplitsForAccountDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FailedDepositSplitsForAccountDTO) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfFailedDepositSplitsForAccountDTO = [0]string{}

// Decode decodes FailedDepositSplitsForAccountDTO from json.
func (s *FailedDepositSplitsForAccountDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FailedDepositSplitsForAccountDTO to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode FailedDepositSplitsForAccountDTO")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FailedDepositSplitsForAccountDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FailedDepositSplitsForAccountDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FastifyDepositScheduleDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FastifyDepositScheduleDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("customerBankUuid")
		e.Str(s.CustomerBankUuid)
	}
}

var jsonFieldsNameOfFastifyDepositScheduleDto = [1]string{
	0: "customerBankUuid",
}

// Decode decodes FastifyDepositScheduleDto from json.
func (s *FastifyDepositScheduleDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FastifyDepositScheduleDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "customerBankUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CustomerBankUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FastifyDepositScheduleDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFastifyDepositScheduleDto) {
					name = jsonFieldsNameOfFastifyDepositScheduleDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FastifyDepositScheduleDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FastifyDepositScheduleDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FastifyDepositScheduleInternalDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FastifyDepositScheduleInternalDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("customerBankUuid")
		e.Str(s.CustomerBankUuid)
	}
	{
		e.FieldStart("userId")
		e.Str(s.UserId)
	}
}

var jsonFieldsNameOfFastifyDepositScheduleInternalDto = [2]string{
	0: "customerBankUuid",
	1: "userId",
}

// Decode decodes FastifyDepositScheduleInternalDto from json.
func (s *FastifyDepositScheduleInternalDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FastifyDepositScheduleInternalDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "customerBankUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CustomerBankUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankUuid\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FastifyDepositScheduleInternalDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFastifyDepositScheduleInternalDto) {
					name = jsonFieldsNameOfFastifyDepositScheduleInternalDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FastifyDepositScheduleInternalDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FastifyDepositScheduleInternalDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FundDepositRecordDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FundDepositRecordDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("depositId")
		e.Str(s.DepositId)
	}
	{
		e.FieldStart("referenceNumber")
		e.Str(s.ReferenceNumber)
	}
	{
		e.FieldStart("updatedBy")
		s.UpdatedBy.Encode(e)
	}
	{
		e.FieldStart("isLocalBank")
		e.Bool(s.IsLocalBank)
	}
	{
		e.FieldStart("depositedAmount")
		s.DepositedAmount.Encode(e)
	}
	{
		e.FieldStart("depositedByBankAccountNumber")
		e.Str(s.DepositedByBankAccountNumber)
	}
	{
		e.FieldStart("depositedByName")
		e.Str(s.DepositedByName)
	}
	{
		e.FieldStart("depositDescription")
		e.Str(s.DepositDescription)
	}
	{
		e.FieldStart("depositedDate")
		e.Str(s.DepositedDate)
	}
	{
		e.FieldStart("accountId")
		s.AccountId.Encode(e)
	}
	{
		e.FieldStart("whitelistedDescription")
		s.WhitelistedDescription.Encode(e)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("depositedByBankCode")
		s.DepositedByBankCode.Encode(e)
	}
}

var jsonFieldsNameOfFundDepositRecordDto = [13]string{
	0:  "depositId",
	1:  "referenceNumber",
	2:  "updatedBy",
	3:  "isLocalBank",
	4:  "depositedAmount",
	5:  "depositedByBankAccountNumber",
	6:  "depositedByName",
	7:  "depositDescription",
	8:  "depositedDate",
	9:  "accountId",
	10: "whitelistedDescription",
	11: "status",
	12: "depositedByBankCode",
}

// Decode decodes FundDepositRecordDto from json.
func (s *FundDepositRecordDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FundDepositRecordDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "depositId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DepositId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositId\"")
			}
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ReferenceNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "updatedBy":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBy\"")
			}
		case "isLocalBank":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsLocalBank = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isLocalBank\"")
			}
		case "depositedAmount":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DepositedAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositedAmount\"")
			}
		case "depositedByBankAccountNumber":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DepositedByBankAccountNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositedByBankAccountNumber\"")
			}
		case "depositedByName":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DepositedByName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositedByName\"")
			}
		case "depositDescription":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.DepositDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositDescription\"")
			}
		case "depositedDate":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DepositedDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositedDate\"")
			}
		case "accountId":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "whitelistedDescription":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.WhitelistedDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelistedDescription\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "depositedByBankCode":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.DepositedByBankCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositedByBankCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FundDepositRecordDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFundDepositRecordDto) {
					name = jsonFieldsNameOfFundDepositRecordDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FundDepositRecordDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FundDepositRecordDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetIGTByAccountUuidDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetIGTByAccountUuidDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		e.Str(s.UUID)
	}
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("requestType")
		s.RequestType.Encode(e)
	}
	{
		e.FieldStart("fromPortfolio")
		e.Str(s.FromPortfolio)
	}
	{
		e.FieldStart("toPortfolio")
		e.Str(s.ToPortfolio)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("redemptionExtent")
		s.RedemptionExtent.Encode(e)
	}
	{
		e.FieldStart("scheduleType")
		s.ScheduleType.Encode(e)
	}
	{
		e.FieldStart("requestedCurrency")
		e.Str(s.RequestedCurrency)
	}
	{
		e.FieldStart("requestedAmount")
		e.Float64(s.RequestedAmount)
	}
	{
		e.FieldStart("postedCurrency")
		e.Str(s.PostedCurrency)
	}
	{
		e.FieldStart("postedAmount")
		e.Float64(s.PostedAmount)
	}
	{
		e.FieldStart("fulfilledAmount")
		e.Float64(s.FulfilledAmount)
	}
	{
		e.FieldStart("fulfilledCurrency")
		e.Str(s.FulfilledCurrency)
	}
	{
		e.FieldStart("depositedAmount")
		e.Float64(s.DepositedAmount)
	}
	{
		e.FieldStart("depositedCurrency")
		e.Str(s.DepositedCurrency)
	}
	{
		e.FieldStart("completedAt")
		json.EncodeDateTime(e, s.CompletedAt)
	}
	{
		e.FieldStart("failureReason")
		e.Str(s.FailureReason)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		e.FieldStart("requestedBy")
		e.Str(s.RequestedBy)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("fundingSource")
		s.FundingSource.Encode(e)
	}
}

var jsonFieldsNameOfGetIGTByAccountUuidDTO = [23]string{
	0:  "uuid",
	1:  "accountUuid",
	2:  "requestType",
	3:  "fromPortfolio",
	4:  "toPortfolio",
	5:  "status",
	6:  "redemptionExtent",
	7:  "scheduleType",
	8:  "requestedCurrency",
	9:  "requestedAmount",
	10: "postedCurrency",
	11: "postedAmount",
	12: "fulfilledAmount",
	13: "fulfilledCurrency",
	14: "depositedAmount",
	15: "depositedCurrency",
	16: "completedAt",
	17: "failureReason",
	18: "reason",
	19: "requestedBy",
	20: "createdAt",
	21: "updatedAt",
	22: "fundingSource",
}

// Decode decodes GetIGTByAccountUuidDTO from json.
func (s *GetIGTByAccountUuidDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIGTByAccountUuidDTO to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "accountUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "requestType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RequestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestType\"")
			}
		case "fromPortfolio":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FromPortfolio = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fromPortfolio\"")
			}
		case "toPortfolio":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ToPortfolio = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"toPortfolio\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "redemptionExtent":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.RedemptionExtent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redemptionExtent\"")
			}
		case "scheduleType":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.ScheduleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduleType\"")
			}
		case "requestedCurrency":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RequestedCurrency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedCurrency\"")
			}
		case "requestedAmount":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.RequestedAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedAmount\"")
			}
		case "postedCurrency":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PostedCurrency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postedCurrency\"")
			}
		case "postedAmount":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.PostedAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postedAmount\"")
			}
		case "fulfilledAmount":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.FulfilledAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fulfilledAmount\"")
			}
		case "fulfilledCurrency":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.FulfilledCurrency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fulfilledCurrency\"")
			}
		case "depositedAmount":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.DepositedAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositedAmount\"")
			}
		case "depositedCurrency":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.DepositedCurrency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"depositedCurrency\"")
			}
		case "completedAt":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CompletedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedAt\"")
			}
		case "failureReason":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FailureReason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failureReason\"")
			}
		case "reason":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "requestedBy":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.RequestedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedBy\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "fundingSource":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FundingSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundingSource\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetIGTByAccountUuidDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetIGTByAccountUuidDTO) {
					name = jsonFieldsNameOfGetIGTByAccountUuidDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetIGTByAccountUuidDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIGTByAccountUuidDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIGTByAccountUuidDTOFundingSource as json.
func (s GetIGTByAccountUuidDTOFundingSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetIGTByAccountUuidDTOFundingSource from json.
func (s *GetIGTByAccountUuidDTOFundingSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIGTByAccountUuidDTOFundingSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetIGTByAccountUuidDTOFundingSource(v) {
	case GetIGTByAccountUuidDTOFundingSourceUNKNOWN:
		*s = GetIGTByAccountUuidDTOFundingSourceUNKNOWN
	case GetIGTByAccountUuidDTOFundingSourcePERSONAL:
		*s = GetIGTByAccountUuidDTOFundingSourcePERSONAL
	case GetIGTByAccountUuidDTOFundingSourceSRS:
		*s = GetIGTByAccountUuidDTOFundingSourceSRS
	case GetIGTByAccountUuidDTOFundingSourceCPFIA:
		*s = GetIGTByAccountUuidDTOFundingSourceCPFIA
	case GetIGTByAccountUuidDTOFundingSourceIFASTSRS:
		*s = GetIGTByAccountUuidDTOFundingSourceIFASTSRS
	default:
		*s = GetIGTByAccountUuidDTOFundingSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetIGTByAccountUuidDTOFundingSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIGTByAccountUuidDTOFundingSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIGTByAccountUuidDTORedemptionExtent as json.
func (s GetIGTByAccountUuidDTORedemptionExtent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetIGTByAccountUuidDTORedemptionExtent from json.
func (s *GetIGTByAccountUuidDTORedemptionExtent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIGTByAccountUuidDTORedemptionExtent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetIGTByAccountUuidDTORedemptionExtent(v) {
	case GetIGTByAccountUuidDTORedemptionExtentFULL:
		*s = GetIGTByAccountUuidDTORedemptionExtentFULL
	case GetIGTByAccountUuidDTORedemptionExtentPARTIAL:
		*s = GetIGTByAccountUuidDTORedemptionExtentPARTIAL
	default:
		*s = GetIGTByAccountUuidDTORedemptionExtent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetIGTByAccountUuidDTORedemptionExtent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIGTByAccountUuidDTORedemptionExtent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIGTByAccountUuidDTORequestType as json.
func (s GetIGTByAccountUuidDTORequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetIGTByAccountUuidDTORequestType from json.
func (s *GetIGTByAccountUuidDTORequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIGTByAccountUuidDTORequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetIGTByAccountUuidDTORequestType(v) {
	case GetIGTByAccountUuidDTORequestTypeAUTOPAYOUTTRANSFER:
		*s = GetIGTByAccountUuidDTORequestTypeAUTOPAYOUTTRANSFER
	case GetIGTByAccountUuidDTORequestTypeREQUESTBYUSER:
		*s = GetIGTByAccountUuidDTORequestTypeREQUESTBYUSER
	case GetIGTByAccountUuidDTORequestTypeOPSINITIATED:
		*s = GetIGTByAccountUuidDTORequestTypeOPSINITIATED
	default:
		*s = GetIGTByAccountUuidDTORequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetIGTByAccountUuidDTORequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIGTByAccountUuidDTORequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIGTByAccountUuidDTOScheduleType as json.
func (s GetIGTByAccountUuidDTOScheduleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetIGTByAccountUuidDTOScheduleType from json.
func (s *GetIGTByAccountUuidDTOScheduleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIGTByAccountUuidDTOScheduleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetIGTByAccountUuidDTOScheduleType(v) {
	case GetIGTByAccountUuidDTOScheduleTypeONETIME:
		*s = GetIGTByAccountUuidDTOScheduleTypeONETIME
	case GetIGTByAccountUuidDTOScheduleTypeRECURRING:
		*s = GetIGTByAccountUuidDTOScheduleTypeRECURRING
	default:
		*s = GetIGTByAccountUuidDTOScheduleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetIGTByAccountUuidDTOScheduleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIGTByAccountUuidDTOScheduleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetIGTByAccountUuidDTOStatus as json.
func (s GetIGTByAccountUuidDTOStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetIGTByAccountUuidDTOStatus from json.
func (s *GetIGTByAccountUuidDTOStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetIGTByAccountUuidDTOStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetIGTByAccountUuidDTOStatus(v) {
	case GetIGTByAccountUuidDTOStatusCOMPLETED:
		*s = GetIGTByAccountUuidDTOStatusCOMPLETED
	case GetIGTByAccountUuidDTOStatusFAILED:
		*s = GetIGTByAccountUuidDTOStatusFAILED
	case GetIGTByAccountUuidDTOStatusPENDING:
		*s = GetIGTByAccountUuidDTOStatusPENDING
	case GetIGTByAccountUuidDTOStatusINITIATED:
		*s = GetIGTByAccountUuidDTOStatusINITIATED
	case GetIGTByAccountUuidDTOStatusCANCELLED:
		*s = GetIGTByAccountUuidDTOStatusCANCELLED
	default:
		*s = GetIGTByAccountUuidDTOStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetIGTByAccountUuidDTOStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetIGTByAccountUuidDTOStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetLeanCustomerDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetLeanCustomerDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("leanCustomerUuid")
		e.Str(s.LeanCustomerUuid)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetLeanCustomerDto = [4]string{
	0: "accountUuid",
	1: "leanCustomerUuid",
	2: "createdAt",
	3: "updatedAt",
}

// Decode decodes GetLeanCustomerDto from json.
func (s *GetLeanCustomerDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLeanCustomerDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "leanCustomerUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.LeanCustomerUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leanCustomerUuid\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetLeanCustomerDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetLeanCustomerDto) {
					name = jsonFieldsNameOfGetLeanCustomerDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLeanCustomerDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLeanCustomerDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetLeanTokenDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetLeanTokenDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
	{
		e.FieldStart("tokenType")
		e.Str(s.TokenType)
	}
	{
		e.FieldStart("expiresIn")
		e.Float64(s.ExpiresIn)
	}
	{
		e.FieldStart("scope")
		e.Str(s.Scope)
	}
}

var jsonFieldsNameOfGetLeanTokenDto = [4]string{
	0: "accessToken",
	1: "tokenType",
	2: "expiresIn",
	3: "scope",
}

// Decode decodes GetLeanTokenDto from json.
func (s *GetLeanTokenDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLeanTokenDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		case "tokenType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TokenType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenType\"")
			}
		case "expiresIn":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.ExpiresIn = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresIn\"")
			}
		case "scope":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Scope = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetLeanTokenDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetLeanTokenDto) {
					name = jsonFieldsNameOfGetLeanTokenDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLeanTokenDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLeanTokenDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRetailBanksListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRetailBanksListResponse) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRetailBanksListResponse = [0]string{}

// Decode decodes GetRetailBanksListResponse from json.
func (s *GetRetailBanksListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRetailBanksListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRetailBanksListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRetailBanksListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRetailBanksListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitMandateSetupRequestDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitMandateSetupRequestDTO) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInitMandateSetupRequestDTO = [0]string{}

// Decode decodes InitMandateSetupRequestDTO from json.
func (s *InitMandateSetupRequestDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitMandateSetupRequestDTO to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InitMandateSetupRequestDTO")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitMandateSetupRequestDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitMandateSetupRequestDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InitMandateSetupResultDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InitMandateSetupResultDTO) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInitMandateSetupResultDTO = [0]string{}

// Decode decodes InitMandateSetupResultDTO from json.
func (s *InitMandateSetupResultDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InitMandateSetupResultDTO to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InitMandateSetupResultDTO")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InitMandateSetupResultDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InitMandateSetupResultDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON as json.
func (s IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []IntergoalTransferScheduleDTO(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON from json.
func (s *IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON to nil")
	}
	var unwrapped []IntergoalTransferScheduleDTO
	if err := func() error {
		unwrapped = make([]IntergoalTransferScheduleDTO, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem IntergoalTransferScheduleDTO
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON as json.
func (s IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GetIGTByAccountUuidDTO(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON from json.
func (s *IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON to nil")
	}
	var unwrapped []GetIGTByAccountUuidDTO
	if err := func() error {
		unwrapped = make([]GetIGTByAccountUuidDTO, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GetIGTByAccountUuidDTO
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IntergoalTransferScheduleDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IntergoalTransferScheduleDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("frequency")
		e.Str(s.Frequency)
	}
	{
		e.FieldStart("nextDate")
		e.Str(s.NextDate)
	}
	{
		e.FieldStart("endDate")
		e.Str(s.EndDate)
	}
}

var jsonFieldsNameOfIntergoalTransferScheduleDTO = [7]string{
	0: "id",
	1: "status",
	2: "currency",
	3: "amount",
	4: "frequency",
	5: "nextDate",
	6: "endDate",
}

// Decode decodes IntergoalTransferScheduleDTO from json.
func (s *IntergoalTransferScheduleDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IntergoalTransferScheduleDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "currency":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "frequency":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Frequency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequency\"")
			}
		case "nextDate":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.NextDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextDate\"")
			}
		case "endDate":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.EndDate = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IntergoalTransferScheduleDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIntergoalTransferScheduleDTO) {
					name = jsonFieldsNameOfIntergoalTransferScheduleDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IntergoalTransferScheduleDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IntergoalTransferScheduleDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSubmitWithdrawalRequestsInputDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSubmitWithdrawalRequestsInputDto) encodeFields(e *jx.Encoder) {
	{
		if s.RequestId.Set {
			e.FieldStart("requestId")
			s.RequestId.Encode(e)
		}
	}
	{
		e.FieldStart("userId")
		e.Str(s.UserId)
	}
	{
		if s.CustomerBankId.Set {
			e.FieldStart("customerBankId")
			s.CustomerBankId.Encode(e)
		}
	}
	{
		if s.AdminBank.Set {
			e.FieldStart("adminBank")
			s.AdminBank.Encode(e)
		}
	}
	{
		if s.WithdrawalCurrency.Set {
			e.FieldStart("withdrawalCurrency")
			s.WithdrawalCurrency.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
	{
		e.FieldStart("withdrawals")
		e.ArrStart()
		for _, elem := range s.Withdrawals {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.WithdrawalType.Set {
			e.FieldStart("withdrawalType")
			s.WithdrawalType.Encode(e)
		}
	}
	{
		if s.ClosePortfolioOnFullWithdrawal.Set {
			e.FieldStart("closePortfolioOnFullWithdrawal")
			s.ClosePortfolioOnFullWithdrawal.Encode(e)
		}
	}
	{
		if s.ConvertPartialToFullIfExceedsThreshold.Set {
			e.FieldStart("convertPartialToFullIfExceedsThreshold")
			s.ConvertPartialToFullIfExceedsThreshold.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSubmitWithdrawalRequestsInputDto = [11]string{
	0:  "requestId",
	1:  "userId",
	2:  "customerBankId",
	3:  "adminBank",
	4:  "withdrawalCurrency",
	5:  "reason",
	6:  "comment",
	7:  "withdrawals",
	8:  "withdrawalType",
	9:  "closePortfolioOnFullWithdrawal",
	10: "convertPartialToFullIfExceedsThreshold",
}

// Decode decodes InternalSubmitWithdrawalRequestsInputDto from json.
func (s *InternalSubmitWithdrawalRequestsInputDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSubmitWithdrawalRequestsInputDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requestId":
			if err := func() error {
				s.RequestId.Reset()
				if err := s.RequestId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		case "userId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		case "customerBankId":
			if err := func() error {
				s.CustomerBankId.Reset()
				if err := s.CustomerBankId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankId\"")
			}
		case "adminBank":
			if err := func() error {
				s.AdminBank.Reset()
				if err := s.AdminBank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminBank\"")
			}
		case "withdrawalCurrency":
			if err := func() error {
				s.WithdrawalCurrency.Reset()
				if err := s.WithdrawalCurrency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalCurrency\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "withdrawals":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Withdrawals = make([]WithdrawalRequestDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WithdrawalRequestDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Withdrawals = append(s.Withdrawals, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawals\"")
			}
		case "withdrawalType":
			if err := func() error {
				s.WithdrawalType.Reset()
				if err := s.WithdrawalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalType\"")
			}
		case "closePortfolioOnFullWithdrawal":
			if err := func() error {
				s.ClosePortfolioOnFullWithdrawal.Reset()
				if err := s.ClosePortfolioOnFullWithdrawal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closePortfolioOnFullWithdrawal\"")
			}
		case "convertPartialToFullIfExceedsThreshold":
			if err := func() error {
				s.ConvertPartialToFullIfExceedsThreshold.Reset()
				if err := s.ConvertPartialToFullIfExceedsThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"convertPartialToFullIfExceedsThreshold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSubmitWithdrawalRequestsInputDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInternalSubmitWithdrawalRequestsInputDto) {
					name = jsonFieldsNameOfInternalSubmitWithdrawalRequestsInputDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSubmitWithdrawalRequestsInputDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSubmitWithdrawalRequestsInputDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InternalSubmitWithdrawalRequestsInputDtoWithdrawalType as json.
func (s InternalSubmitWithdrawalRequestsInputDtoWithdrawalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InternalSubmitWithdrawalRequestsInputDtoWithdrawalType from json.
func (s *InternalSubmitWithdrawalRequestsInputDtoWithdrawalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSubmitWithdrawalRequestsInputDtoWithdrawalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InternalSubmitWithdrawalRequestsInputDtoWithdrawalType(v) {
	case InternalSubmitWithdrawalRequestsInputDtoWithdrawalTypeAUTOPAYOUTWITHDRAWAL:
		*s = InternalSubmitWithdrawalRequestsInputDtoWithdrawalTypeAUTOPAYOUTWITHDRAWAL
	case InternalSubmitWithdrawalRequestsInputDtoWithdrawalTypeWITHDRAWALBYCUSTOMER:
		*s = InternalSubmitWithdrawalRequestsInputDtoWithdrawalTypeWITHDRAWALBYCUSTOMER
	case InternalSubmitWithdrawalRequestsInputDtoWithdrawalTypeWITHDRAWALBYOPS:
		*s = InternalSubmitWithdrawalRequestsInputDtoWithdrawalTypeWITHDRAWALBYOPS
	default:
		*s = InternalSubmitWithdrawalRequestsInputDtoWithdrawalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InternalSubmitWithdrawalRequestsInputDtoWithdrawalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSubmitWithdrawalRequestsInputDtoWithdrawalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeanPaymentIntentCancelInputDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeanPaymentIntentCancelInputDto) encodeFields(e *jx.Encoder) {
	{
		if s.CancellationReason.Set {
			e.FieldStart("cancellationReason")
			s.CancellationReason.Encode(e)
		}
	}
	{
		if s.CancellationComments.Set {
			e.FieldStart("cancellationComments")
			s.CancellationComments.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeanPaymentIntentCancelInputDto = [2]string{
	0: "cancellationReason",
	1: "cancellationComments",
}

// Decode decodes LeanPaymentIntentCancelInputDto from json.
func (s *LeanPaymentIntentCancelInputDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeanPaymentIntentCancelInputDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cancellationReason":
			if err := func() error {
				s.CancellationReason.Reset()
				if err := s.CancellationReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancellationReason\"")
			}
		case "cancellationComments":
			if err := func() error {
				s.CancellationComments.Reset()
				if err := s.CancellationComments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancellationComments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeanPaymentIntentCancelInputDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeanPaymentIntentCancelInputDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeanPaymentIntentCancelInputDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeanPaymentIntentDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeanPaymentIntentDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("leanPaymentIntentId")
		e.Str(s.LeanPaymentIntentId)
	}
}

var jsonFieldsNameOfLeanPaymentIntentDto = [1]string{
	0: "leanPaymentIntentId",
}

// Decode decodes LeanPaymentIntentDto from json.
func (s *LeanPaymentIntentDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeanPaymentIntentDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "leanPaymentIntentId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LeanPaymentIntentId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leanPaymentIntentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeanPaymentIntentDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeanPaymentIntentDto) {
					name = jsonFieldsNameOfLeanPaymentIntentDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeanPaymentIntentDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeanPaymentIntentDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeanPaymentIntentInputDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeanPaymentIntentInputDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("portfolioUuid")
		e.Str(s.PortfolioUuid)
	}
	{
		e.FieldStart("customerBankUuid")
		e.Str(s.CustomerBankUuid)
	}
}

var jsonFieldsNameOfLeanPaymentIntentInputDto = [3]string{
	0: "amount",
	1: "portfolioUuid",
	2: "customerBankUuid",
}

// Decode decodes LeanPaymentIntentInputDto from json.
func (s *LeanPaymentIntentInputDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeanPaymentIntentInputDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "amount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "portfolioUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portfolioUuid\"")
			}
		case "customerBankUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CustomerBankUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customerBankUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeanPaymentIntentInputDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeanPaymentIntentInputDto) {
					name = jsonFieldsNameOfLeanPaymentIntentInputDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeanPaymentIntentInputDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeanPaymentIntentInputDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeanScheduledPaymentIntentInputDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeanScheduledPaymentIntentInputDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("persistentDepositScheduleUuid")
		e.Str(s.PersistentDepositScheduleUuid)
	}
}

var jsonFieldsNameOfLeanScheduledPaymentIntentInputDto = [1]string{
	0: "persistentDepositScheduleUuid",
}

// Decode decodes LeanScheduledPaymentIntentInputDto from json.
func (s *LeanScheduledPaymentIntentInputDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeanScheduledPaymentIntentInputDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "persistentDepositScheduleUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PersistentDepositScheduleUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentDepositScheduleUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeanScheduledPaymentIntentInputDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeanScheduledPaymentIntentInputDto) {
					name = jsonFieldsNameOfLeanScheduledPaymentIntentInputDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeanScheduledPaymentIntentInputDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeanScheduledPaymentIntentInputDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LeanUnlinkBankDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LeanUnlinkBankDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("leanCustomerUUID")
		e.Str(s.LeanCustomerUUID)
	}
	{
		e.FieldStart("bankIdentifier")
		e.Str(s.BankIdentifier)
	}
	{
		if s.DeletedBy.Set {
			e.FieldStart("deletedBy")
			s.DeletedBy.Encode(e)
		}
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
}

var jsonFieldsNameOfLeanUnlinkBankDto = [4]string{
	0: "leanCustomerUUID",
	1: "bankIdentifier",
	2: "deletedBy",
	3: "force",
}

// Decode decodes LeanUnlinkBankDto from json.
func (s *LeanUnlinkBankDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LeanUnlinkBankDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "leanCustomerUUID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LeanCustomerUUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leanCustomerUUID\"")
			}
		case "bankIdentifier":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BankIdentifier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankIdentifier\"")
			}
		case "deletedBy":
			if err := func() error {
				s.DeletedBy.Reset()
				if err := s.DeletedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedBy\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LeanUnlinkBankDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLeanUnlinkBankDto) {
					name = jsonFieldsNameOfLeanUnlinkBankDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LeanUnlinkBankDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LeanUnlinkBankDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Money) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Money) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
}

var jsonFieldsNameOfMoney = [2]string{
	0: "currency",
	1: "amount",
}

// Decode decodes Money from json.
func (s *Money) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Money to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Money")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMoney) {
					name = jsonFieldsNameOfMoney[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Money) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Money) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdminBankDto as json.
func (o OptAdminBankDto) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AdminBankDto from json.
func (o *OptAdminBankDto) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAdminBankDto to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAdminBankDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAdminBankDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDepositScheduleDtoFrequency as json.
func (o OptCreateDepositScheduleDtoFrequency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateDepositScheduleDtoFrequency from json.
func (o *OptCreateDepositScheduleDtoFrequency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDepositScheduleDtoFrequency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDepositScheduleDtoFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDepositScheduleDtoFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDepositScheduleRequestDtoFrequency as json.
func (o OptCreateDepositScheduleRequestDtoFrequency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateDepositScheduleRequestDtoFrequency from json.
func (o *OptCreateDepositScheduleRequestDtoFrequency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDepositScheduleRequestDtoFrequency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDepositScheduleRequestDtoFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDepositScheduleRequestDtoFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DepositScheduleDtoFrequency as json.
func (o OptDepositScheduleDtoFrequency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DepositScheduleDtoFrequency from json.
func (o *OptDepositScheduleDtoFrequency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDepositScheduleDtoFrequency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDepositScheduleDtoFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDepositScheduleDtoFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DepositScheduleViewFrequency as json.
func (o OptDepositScheduleViewFrequency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DepositScheduleViewFrequency from json.
func (o *OptDepositScheduleViewFrequency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDepositScheduleViewFrequency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDepositScheduleViewFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDepositScheduleViewFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InternalSubmitWithdrawalRequestsInputDtoWithdrawalType as json.
func (o OptInternalSubmitWithdrawalRequestsInputDtoWithdrawalType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InternalSubmitWithdrawalRequestsInputDtoWithdrawalType from json.
func (o *OptInternalSubmitWithdrawalRequestsInputDtoWithdrawalType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInternalSubmitWithdrawalRequestsInputDtoWithdrawalType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInternalSubmitWithdrawalRequestsInputDtoWithdrawalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInternalSubmitWithdrawalRequestsInputDtoWithdrawalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Money as json.
func (o OptMoney) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Money from json.
func (o *OptMoney) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMoney to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMoney) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMoney) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SrsSubTransferWithdrawalCostBasisForBank as json.
func (o OptSrsSubTransferWithdrawalCostBasisForBank) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SrsSubTransferWithdrawalCostBasisForBank from json.
func (o *OptSrsSubTransferWithdrawalCostBasisForBank) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSrsSubTransferWithdrawalCostBasisForBank to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSrsSubTransferWithdrawalCostBasisForBank) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSrsSubTransferWithdrawalCostBasisForBank) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OriginalTransferSourceAsDestination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OriginalTransferSourceAsDestination) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("recordId")
		e.Str(s.RecordId)
	}
	{
		e.FieldStart("details")
		e.Str(s.Details)
	}
}

var jsonFieldsNameOfOriginalTransferSourceAsDestination = [3]string{
	0: "currency",
	1: "recordId",
	2: "details",
}

// Decode decodes OriginalTransferSourceAsDestination from json.
func (s *OriginalTransferSourceAsDestination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OriginalTransferSourceAsDestination to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "recordId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RecordId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recordId\"")
			}
		case "details":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Details = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OriginalTransferSourceAsDestination")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOriginalTransferSourceAsDestination) {
					name = jsonFieldsNameOfOriginalTransferSourceAsDestination[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OriginalTransferSourceAsDestination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OriginalTransferSourceAsDestination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SoftDeleteDepositScheduleRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SoftDeleteDepositScheduleRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("persistentUuid")
		e.Str(s.PersistentUuid)
	}
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("deletedBy")
		e.Str(s.DeletedBy)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
}

var jsonFieldsNameOfSoftDeleteDepositScheduleRequestDto = [4]string{
	0: "persistentUuid",
	1: "accountUuid",
	2: "deletedBy",
	3: "reason",
}

// Decode decodes SoftDeleteDepositScheduleRequestDto from json.
func (s *SoftDeleteDepositScheduleRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SoftDeleteDepositScheduleRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "persistentUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PersistentUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"persistentUuid\"")
			}
		case "accountUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "deletedBy":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DeletedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedBy\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SoftDeleteDepositScheduleRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSoftDeleteDepositScheduleRequestDto) {
					name = jsonFieldsNameOfSoftDeleteDepositScheduleRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SoftDeleteDepositScheduleRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SoftDeleteDepositScheduleRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SrsSubTransfer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SrsSubTransfer) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("requestId")
		e.Str(s.RequestId)
	}
	{
		e.FieldStart("accountId")
		e.Str(s.AccountId)
	}
	{
		e.FieldStart("amount")
		s.Amount.Encode(e)
	}
	{
		e.FieldStart("bankName")
		e.Str(s.BankName)
	}
	{
		e.FieldStart("bankAccountNumber")
		e.Str(s.BankAccountNumber)
	}
	{
		e.FieldStart("legalName")
		e.Str(s.LegalName)
	}
	{
		e.FieldStart("reference")
		e.Str(s.Reference)
	}
	{
		e.FieldStart("identificationNumber")
		e.Str(s.IdentificationNumber)
	}
	{
		if s.WithdrawalCommentForBank.Set {
			e.FieldStart("withdrawalCommentForBank")
			s.WithdrawalCommentForBank.Encode(e)
		}
	}
	{
		if s.WithdrawalCostBasisForBank.Set {
			e.FieldStart("withdrawalCostBasisForBank")
			s.WithdrawalCostBasisForBank.Encode(e)
		}
	}
}

var jsonFieldsNameOfSrsSubTransfer = [10]string{
	0: "requestId",
	1: "accountId",
	2: "amount",
	3: "bankName",
	4: "bankAccountNumber",
	5: "legalName",
	6: "reference",
	7: "identificationNumber",
	8: "withdrawalCommentForBank",
	9: "withdrawalCostBasisForBank",
}

// Decode decodes SrsSubTransfer from json.
func (s *SrsSubTransfer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SrsSubTransfer to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requestId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RequestId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		case "accountId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AccountId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "bankName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BankName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankName\"")
			}
		case "bankAccountNumber":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.BankAccountNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bankAccountNumber\"")
			}
		case "legalName":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LegalName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legalName\"")
			}
		case "reference":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Reference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		case "identificationNumber":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.IdentificationNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identificationNumber\"")
			}
		case "withdrawalCommentForBank":
			if err := func() error {
				s.WithdrawalCommentForBank.Reset()
				if err := s.WithdrawalCommentForBank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalCommentForBank\"")
			}
		case "withdrawalCostBasisForBank":
			if err := func() error {
				s.WithdrawalCostBasisForBank.Reset()
				if err := s.WithdrawalCostBasisForBank.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalCostBasisForBank\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SrsSubTransfer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSrsSubTransfer) {
					name = jsonFieldsNameOfSrsSubTransfer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SrsSubTransfer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SrsSubTransfer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SrsSubTransferWithdrawalCostBasisForBank) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SrsSubTransferWithdrawalCostBasisForBank) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
}

var jsonFieldsNameOfSrsSubTransferWithdrawalCostBasisForBank = [2]string{
	0: "currency",
	1: "amount",
}

// Decode decodes SrsSubTransferWithdrawalCostBasisForBank from json.
func (s *SrsSubTransferWithdrawalCostBasisForBank) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SrsSubTransferWithdrawalCostBasisForBank to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SrsSubTransferWithdrawalCostBasisForBank")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSrsSubTransferWithdrawalCostBasisForBank) {
					name = jsonFieldsNameOfSrsSubTransferWithdrawalCostBasisForBank[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SrsSubTransferWithdrawalCostBasisForBank) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SrsSubTransferWithdrawalCostBasisForBank) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SrsTransferRequestSubtransfers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SrsTransferRequestSubtransfers) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("transferRequest")
		s.TransferRequest.Encode(e)
	}
	{
		e.FieldStart("subTransfers")
		e.ArrStart()
		for _, elem := range s.SubTransfers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSrsTransferRequestSubtransfers = [2]string{
	0: "transferRequest",
	1: "subTransfers",
}

// Decode decodes SrsTransferRequestSubtransfers from json.
func (s *SrsTransferRequestSubtransfers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SrsTransferRequestSubtransfers to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transferRequest":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TransferRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transferRequest\"")
			}
		case "subTransfers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.SubTransfers = make([]SrsSubTransfer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SrsSubTransfer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SubTransfers = append(s.SubTransfers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subTransfers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SrsTransferRequestSubtransfers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSrsTransferRequestSubtransfers) {
					name = jsonFieldsNameOfSrsTransferRequestSubtransfers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SrsTransferRequestSubtransfers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SrsTransferRequestSubtransfers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartIGTRequestWorkflowExternalRequestDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartIGTRequestWorkflowExternalRequestDTO) encodeFields(e *jx.Encoder) {
	{
		if s.IgtRequestUuid.Set {
			e.FieldStart("igtRequestUuid")
			s.IgtRequestUuid.Encode(e)
		}
	}
	{
		e.FieldStart("fromGoalId")
		e.Str(s.FromGoalId)
	}
	{
		e.FieldStart("toGoalId")
		e.Str(s.ToGoalId)
	}
	{
		e.FieldStart("transferAmount")
		e.Float64(s.TransferAmount)
	}
	{
		e.FieldStart("transferCurrency")
		e.Str(s.TransferCurrency)
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartIGTRequestWorkflowExternalRequestDTO = [6]string{
	0: "igtRequestUuid",
	1: "fromGoalId",
	2: "toGoalId",
	3: "transferAmount",
	4: "transferCurrency",
	5: "comment",
}

// Decode decodes StartIGTRequestWorkflowExternalRequestDTO from json.
func (s *StartIGTRequestWorkflowExternalRequestDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowExternalRequestDTO to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "igtRequestUuid":
			if err := func() error {
				s.IgtRequestUuid.Reset()
				if err := s.IgtRequestUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"igtRequestUuid\"")
			}
		case "fromGoalId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FromGoalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fromGoalId\"")
			}
		case "toGoalId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ToGoalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"toGoalId\"")
			}
		case "transferAmount":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TransferAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transferAmount\"")
			}
		case "transferCurrency":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TransferCurrency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transferCurrency\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartIGTRequestWorkflowExternalRequestDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartIGTRequestWorkflowExternalRequestDTO) {
					name = jsonFieldsNameOfStartIGTRequestWorkflowExternalRequestDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartIGTRequestWorkflowExternalRequestDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowExternalRequestDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartIGTRequestWorkflowRequestDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartIGTRequestWorkflowRequestDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("igtRequestUuid")
		e.Str(s.IgtRequestUuid)
	}
	{
		if s.ConvertPartialToFullIfExceedsThreshold.Set {
			e.FieldStart("convertPartialToFullIfExceedsThreshold")
			s.ConvertPartialToFullIfExceedsThreshold.Encode(e)
		}
	}
	{
		if s.ClosePortfolioOnFullWithdrawal.Set {
			e.FieldStart("closePortfolioOnFullWithdrawal")
			s.ClosePortfolioOnFullWithdrawal.Encode(e)
		}
	}
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("sourcePortfolioUuid")
		e.Str(s.SourcePortfolioUuid)
	}
	{
		e.FieldStart("destinationPortfolioUuid")
		e.Str(s.DestinationPortfolioUuid)
	}
	{
		e.FieldStart("requestType")
		s.RequestType.Encode(e)
	}
	{
		e.FieldStart("scheduleType")
		s.ScheduleType.Encode(e)
	}
	{
		e.FieldStart("requestedAmount")
		s.RequestedAmount.Encode(e)
	}
	{
		if s.ShouldSkipNotification.Set {
			e.FieldStart("shouldSkipNotification")
			s.ShouldSkipNotification.Encode(e)
		}
	}
	{
		if s.RequestedBy.Set {
			e.FieldStart("requestedBy")
			s.RequestedBy.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartIGTRequestWorkflowRequestDTO = [12]string{
	0:  "igtRequestUuid",
	1:  "convertPartialToFullIfExceedsThreshold",
	2:  "closePortfolioOnFullWithdrawal",
	3:  "accountUuid",
	4:  "sourcePortfolioUuid",
	5:  "destinationPortfolioUuid",
	6:  "requestType",
	7:  "scheduleType",
	8:  "requestedAmount",
	9:  "shouldSkipNotification",
	10: "requestedBy",
	11: "reason",
}

// Decode decodes StartIGTRequestWorkflowRequestDTO from json.
func (s *StartIGTRequestWorkflowRequestDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowRequestDTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "igtRequestUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IgtRequestUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"igtRequestUuid\"")
			}
		case "convertPartialToFullIfExceedsThreshold":
			if err := func() error {
				s.ConvertPartialToFullIfExceedsThreshold.Reset()
				if err := s.ConvertPartialToFullIfExceedsThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"convertPartialToFullIfExceedsThreshold\"")
			}
		case "closePortfolioOnFullWithdrawal":
			if err := func() error {
				s.ClosePortfolioOnFullWithdrawal.Reset()
				if err := s.ClosePortfolioOnFullWithdrawal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closePortfolioOnFullWithdrawal\"")
			}
		case "accountUuid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "sourcePortfolioUuid":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SourcePortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourcePortfolioUuid\"")
			}
		case "destinationPortfolioUuid":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DestinationPortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destinationPortfolioUuid\"")
			}
		case "requestType":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.RequestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestType\"")
			}
		case "scheduleType":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.ScheduleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduleType\"")
			}
		case "requestedAmount":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.RequestedAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedAmount\"")
			}
		case "shouldSkipNotification":
			if err := func() error {
				s.ShouldSkipNotification.Reset()
				if err := s.ShouldSkipNotification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shouldSkipNotification\"")
			}
		case "requestedBy":
			if err := func() error {
				s.RequestedBy.Reset()
				if err := s.RequestedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedBy\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartIGTRequestWorkflowRequestDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartIGTRequestWorkflowRequestDTO) {
					name = jsonFieldsNameOfStartIGTRequestWorkflowRequestDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartIGTRequestWorkflowRequestDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowRequestDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartIGTRequestWorkflowRequestDTORequestType as json.
func (s StartIGTRequestWorkflowRequestDTORequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartIGTRequestWorkflowRequestDTORequestType from json.
func (s *StartIGTRequestWorkflowRequestDTORequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowRequestDTORequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartIGTRequestWorkflowRequestDTORequestType(v) {
	case StartIGTRequestWorkflowRequestDTORequestTypeAUTOPAYOUTTRANSFER:
		*s = StartIGTRequestWorkflowRequestDTORequestTypeAUTOPAYOUTTRANSFER
	case StartIGTRequestWorkflowRequestDTORequestTypeREQUESTBYUSER:
		*s = StartIGTRequestWorkflowRequestDTORequestTypeREQUESTBYUSER
	case StartIGTRequestWorkflowRequestDTORequestTypeOPSINITIATED:
		*s = StartIGTRequestWorkflowRequestDTORequestTypeOPSINITIATED
	default:
		*s = StartIGTRequestWorkflowRequestDTORequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartIGTRequestWorkflowRequestDTORequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowRequestDTORequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartIGTRequestWorkflowRequestDTORequestedAmount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartIGTRequestWorkflowRequestDTORequestedAmount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
}

var jsonFieldsNameOfStartIGTRequestWorkflowRequestDTORequestedAmount = [2]string{
	0: "currency",
	1: "amount",
}

// Decode decodes StartIGTRequestWorkflowRequestDTORequestedAmount from json.
func (s *StartIGTRequestWorkflowRequestDTORequestedAmount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowRequestDTORequestedAmount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartIGTRequestWorkflowRequestDTORequestedAmount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartIGTRequestWorkflowRequestDTORequestedAmount) {
					name = jsonFieldsNameOfStartIGTRequestWorkflowRequestDTORequestedAmount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartIGTRequestWorkflowRequestDTORequestedAmount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowRequestDTORequestedAmount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartIGTRequestWorkflowRequestDTOScheduleType as json.
func (s StartIGTRequestWorkflowRequestDTOScheduleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartIGTRequestWorkflowRequestDTOScheduleType from json.
func (s *StartIGTRequestWorkflowRequestDTOScheduleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowRequestDTOScheduleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartIGTRequestWorkflowRequestDTOScheduleType(v) {
	case StartIGTRequestWorkflowRequestDTOScheduleTypeONETIME:
		*s = StartIGTRequestWorkflowRequestDTOScheduleTypeONETIME
	case StartIGTRequestWorkflowRequestDTOScheduleTypeRECURRING:
		*s = StartIGTRequestWorkflowRequestDTOScheduleTypeRECURRING
	default:
		*s = StartIGTRequestWorkflowRequestDTOScheduleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartIGTRequestWorkflowRequestDTOScheduleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowRequestDTOScheduleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartIGTRequestWorkflowSuccessResponseDTO) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("igtRequestUuid")
		e.Str(s.IgtRequestUuid)
	}
	{
		e.FieldStart("accountUuid")
		e.Str(s.AccountUuid)
	}
	{
		e.FieldStart("sourcePortfolioUuid")
		e.Str(s.SourcePortfolioUuid)
	}
	{
		e.FieldStart("destinationPortfolioUuid")
		e.Str(s.DestinationPortfolioUuid)
	}
	{
		e.FieldStart("redemptionExtent")
		s.RedemptionExtent.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("requestType")
		s.RequestType.Encode(e)
	}
	{
		e.FieldStart("scheduleType")
		s.ScheduleType.Encode(e)
	}
	{
		e.FieldStart("requestedAmount")
		s.RequestedAmount.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		e.Str(s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		e.Str(s.UpdatedAt)
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completedAt")
			s.CompletedAt.Encode(e)
		}
	}
	{
		if s.PostedAmount != nil {
			e.FieldStart("postedAmount")
			s.PostedAmount.Encode(e)
		}
	}
	{
		if s.FailureReason.Set {
			e.FieldStart("failureReason")
			s.FailureReason.Encode(e)
		}
	}
	{
		if s.RequestedBy.Set {
			e.FieldStart("requestedBy")
			s.RequestedBy.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartIGTRequestWorkflowSuccessResponseDTO = [16]string{
	0:  "igtRequestUuid",
	1:  "accountUuid",
	2:  "sourcePortfolioUuid",
	3:  "destinationPortfolioUuid",
	4:  "redemptionExtent",
	5:  "status",
	6:  "requestType",
	7:  "scheduleType",
	8:  "requestedAmount",
	9:  "createdAt",
	10: "updatedAt",
	11: "completedAt",
	12: "postedAmount",
	13: "failureReason",
	14: "requestedBy",
	15: "reason",
}

// Decode decodes StartIGTRequestWorkflowSuccessResponseDTO from json.
func (s *StartIGTRequestWorkflowSuccessResponseDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowSuccessResponseDTO to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "igtRequestUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IgtRequestUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"igtRequestUuid\"")
			}
		case "accountUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AccountUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountUuid\"")
			}
		case "sourcePortfolioUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SourcePortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sourcePortfolioUuid\"")
			}
		case "destinationPortfolioUuid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DestinationPortfolioUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destinationPortfolioUuid\"")
			}
		case "redemptionExtent":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.RedemptionExtent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redemptionExtent\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requestType":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.RequestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestType\"")
			}
		case "scheduleType":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.ScheduleType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduleType\"")
			}
		case "requestedAmount":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.RequestedAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedAmount\"")
			}
		case "createdAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.UpdatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "completedAt":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedAt\"")
			}
		case "postedAmount":
			if err := func() error {
				s.PostedAmount = nil
				var elem StartIGTRequestWorkflowSuccessResponseDTOPostedAmount
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PostedAmount = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postedAmount\"")
			}
		case "failureReason":
			if err := func() error {
				s.FailureReason.Reset()
				if err := s.FailureReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failureReason\"")
			}
		case "requestedBy":
			if err := func() error {
				s.RequestedBy.Reset()
				if err := s.RequestedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedBy\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartIGTRequestWorkflowSuccessResponseDTO")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartIGTRequestWorkflowSuccessResponseDTO) {
					name = jsonFieldsNameOfStartIGTRequestWorkflowSuccessResponseDTO[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTOPostedAmount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartIGTRequestWorkflowSuccessResponseDTOPostedAmount) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfStartIGTRequestWorkflowSuccessResponseDTOPostedAmount = [0]string{}

// Decode decodes StartIGTRequestWorkflowSuccessResponseDTOPostedAmount from json.
func (s *StartIGTRequestWorkflowSuccessResponseDTOPostedAmount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowSuccessResponseDTOPostedAmount to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode StartIGTRequestWorkflowSuccessResponseDTOPostedAmount")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTOPostedAmount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTOPostedAmount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent as json.
func (s StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent from json.
func (s *StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent(v) {
	case StartIGTRequestWorkflowSuccessResponseDTORedemptionExtentFULL:
		*s = StartIGTRequestWorkflowSuccessResponseDTORedemptionExtentFULL
	case StartIGTRequestWorkflowSuccessResponseDTORedemptionExtentPARTIAL:
		*s = StartIGTRequestWorkflowSuccessResponseDTORedemptionExtentPARTIAL
	default:
		*s = StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartIGTRequestWorkflowSuccessResponseDTORequestType as json.
func (s StartIGTRequestWorkflowSuccessResponseDTORequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartIGTRequestWorkflowSuccessResponseDTORequestType from json.
func (s *StartIGTRequestWorkflowSuccessResponseDTORequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowSuccessResponseDTORequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartIGTRequestWorkflowSuccessResponseDTORequestType(v) {
	case StartIGTRequestWorkflowSuccessResponseDTORequestTypeAUTOPAYOUTTRANSFER:
		*s = StartIGTRequestWorkflowSuccessResponseDTORequestTypeAUTOPAYOUTTRANSFER
	case StartIGTRequestWorkflowSuccessResponseDTORequestTypeREQUESTBYUSER:
		*s = StartIGTRequestWorkflowSuccessResponseDTORequestTypeREQUESTBYUSER
	case StartIGTRequestWorkflowSuccessResponseDTORequestTypeOPSINITIATED:
		*s = StartIGTRequestWorkflowSuccessResponseDTORequestTypeOPSINITIATED
	default:
		*s = StartIGTRequestWorkflowSuccessResponseDTORequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartIGTRequestWorkflowSuccessResponseDTORequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTORequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTORequestedAmount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartIGTRequestWorkflowSuccessResponseDTORequestedAmount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("currency")
		e.Str(s.Currency)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
}

var jsonFieldsNameOfStartIGTRequestWorkflowSuccessResponseDTORequestedAmount = [2]string{
	0: "currency",
	1: "amount",
}

// Decode decodes StartIGTRequestWorkflowSuccessResponseDTORequestedAmount from json.
func (s *StartIGTRequestWorkflowSuccessResponseDTORequestedAmount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowSuccessResponseDTORequestedAmount to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Currency = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartIGTRequestWorkflowSuccessResponseDTORequestedAmount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartIGTRequestWorkflowSuccessResponseDTORequestedAmount) {
					name = jsonFieldsNameOfStartIGTRequestWorkflowSuccessResponseDTORequestedAmount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTORequestedAmount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTORequestedAmount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartIGTRequestWorkflowSuccessResponseDTOScheduleType as json.
func (s StartIGTRequestWorkflowSuccessResponseDTOScheduleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartIGTRequestWorkflowSuccessResponseDTOScheduleType from json.
func (s *StartIGTRequestWorkflowSuccessResponseDTOScheduleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowSuccessResponseDTOScheduleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartIGTRequestWorkflowSuccessResponseDTOScheduleType(v) {
	case StartIGTRequestWorkflowSuccessResponseDTOScheduleTypeONETIME:
		*s = StartIGTRequestWorkflowSuccessResponseDTOScheduleTypeONETIME
	case StartIGTRequestWorkflowSuccessResponseDTOScheduleTypeRECURRING:
		*s = StartIGTRequestWorkflowSuccessResponseDTOScheduleTypeRECURRING
	default:
		*s = StartIGTRequestWorkflowSuccessResponseDTOScheduleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartIGTRequestWorkflowSuccessResponseDTOScheduleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTOScheduleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartIGTRequestWorkflowSuccessResponseDTOStatus as json.
func (s StartIGTRequestWorkflowSuccessResponseDTOStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartIGTRequestWorkflowSuccessResponseDTOStatus from json.
func (s *StartIGTRequestWorkflowSuccessResponseDTOStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartIGTRequestWorkflowSuccessResponseDTOStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartIGTRequestWorkflowSuccessResponseDTOStatus(v) {
	case StartIGTRequestWorkflowSuccessResponseDTOStatusCOMPLETED:
		*s = StartIGTRequestWorkflowSuccessResponseDTOStatusCOMPLETED
	case StartIGTRequestWorkflowSuccessResponseDTOStatusFAILED:
		*s = StartIGTRequestWorkflowSuccessResponseDTOStatusFAILED
	case StartIGTRequestWorkflowSuccessResponseDTOStatusPENDING:
		*s = StartIGTRequestWorkflowSuccessResponseDTOStatusPENDING
	case StartIGTRequestWorkflowSuccessResponseDTOStatusINITIATED:
		*s = StartIGTRequestWorkflowSuccessResponseDTOStatusINITIATED
	case StartIGTRequestWorkflowSuccessResponseDTOStatusCANCELLED:
		*s = StartIGTRequestWorkflowSuccessResponseDTOStatusCANCELLED
	default:
		*s = StartIGTRequestWorkflowSuccessResponseDTOStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartIGTRequestWorkflowSuccessResponseDTOStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartIGTRequestWorkflowSuccessResponseDTOStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubmitWithdrawalRequestsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubmitWithdrawalRequestsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("withdrawalId")
		e.Str(s.WithdrawalId)
	}
}

var jsonFieldsNameOfSubmitWithdrawalRequestsResponseDto = [1]string{
	0: "withdrawalId",
}

// Decode decodes SubmitWithdrawalRequestsResponseDto from json.
func (s *SubmitWithdrawalRequestsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubmitWithdrawalRequestsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "withdrawalId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WithdrawalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubmitWithdrawalRequestsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubmitWithdrawalRequestsResponseDto) {
					name = jsonFieldsNameOfSubmitWithdrawalRequestsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubmitWithdrawalRequestsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubmitWithdrawalRequestsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThresholdAmendmentDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThresholdAmendmentDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("thresholdName")
		e.Str(s.ThresholdName)
	}
	{
		e.FieldStart("thresholdAmount")
		e.Float64(s.ThresholdAmount)
	}
	{
		e.FieldStart("justification")
		e.Str(s.Justification)
	}
}

var jsonFieldsNameOfThresholdAmendmentDto = [3]string{
	0: "thresholdName",
	1: "thresholdAmount",
	2: "justification",
}

// Decode decodes ThresholdAmendmentDto from json.
func (s *ThresholdAmendmentDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThresholdAmendmentDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "thresholdName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ThresholdName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thresholdName\"")
			}
		case "thresholdAmount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.ThresholdAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thresholdAmount\"")
			}
		case "justification":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Justification = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"justification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThresholdAmendmentDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThresholdAmendmentDto) {
					name = jsonFieldsNameOfThresholdAmendmentDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThresholdAmendmentDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThresholdAmendmentDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("transferRequestId")
		e.Str(s.TransferRequestId)
	}
	{
		e.FieldStart("from")
		s.From.Encode(e)
	}
	{
		e.FieldStart("destinationType")
		s.DestinationType.Encode(e)
	}
	{
		e.FieldStart("to")
		s.To.Encode(e)
	}
	{
		e.FieldStart("referenceNumber")
		e.Str(s.ReferenceNumber)
	}
	{
		e.FieldStart("amount")
		s.Amount.Encode(e)
	}
	{
		if s.SettledDate.Set {
			e.FieldStart("settledDate")
			s.SettledDate.Encode(e)
		}
	}
	{
		if s.SystemCompletedTime.Set {
			e.FieldStart("systemCompletedTime")
			s.SystemCompletedTime.Encode(e)
		}
	}
	{
		if s.SenderSettledDate.Set {
			e.FieldStart("senderSettledDate")
			s.SenderSettledDate.Encode(e)
		}
	}
	{
		if s.RecipientSettledDate.Set {
			e.FieldStart("recipientSettledDate")
			s.RecipientSettledDate.Encode(e)
		}
	}
	{
		if s.SenderSettlement.Set {
			e.FieldStart("senderSettlement")
			s.SenderSettlement.Encode(e)
		}
	}
	{
		if s.RecipientSettlement.Set {
			e.FieldStart("recipientSettlement")
			s.RecipientSettlement.Encode(e)
		}
	}
	{
		e.FieldStart("requestedAt")
		e.Str(s.RequestedAt)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("subTransfers")
		e.ArrStart()
		for _, elem := range s.SubTransfers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTransferRequest = [15]string{
	0:  "transferRequestId",
	1:  "from",
	2:  "destinationType",
	3:  "to",
	4:  "referenceNumber",
	5:  "amount",
	6:  "settledDate",
	7:  "systemCompletedTime",
	8:  "senderSettledDate",
	9:  "recipientSettledDate",
	10: "senderSettlement",
	11: "recipientSettlement",
	12: "requestedAt",
	13: "status",
	14: "subTransfers",
}

// Decode decodes TransferRequest from json.
func (s *TransferRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transferRequestId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TransferRequestId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transferRequestId\"")
			}
		case "from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "destinationType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DestinationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destinationType\"")
			}
		case "to":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		case "referenceNumber":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ReferenceNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenceNumber\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "settledDate":
			if err := func() error {
				s.SettledDate.Reset()
				if err := s.SettledDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settledDate\"")
			}
		case "systemCompletedTime":
			if err := func() error {
				s.SystemCompletedTime.Reset()
				if err := s.SystemCompletedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"systemCompletedTime\"")
			}
		case "senderSettledDate":
			if err := func() error {
				s.SenderSettledDate.Reset()
				if err := s.SenderSettledDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"senderSettledDate\"")
			}
		case "recipientSettledDate":
			if err := func() error {
				s.RecipientSettledDate.Reset()
				if err := s.RecipientSettledDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recipientSettledDate\"")
			}
		case "senderSettlement":
			if err := func() error {
				s.SenderSettlement.Reset()
				if err := s.SenderSettlement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"senderSettlement\"")
			}
		case "recipientSettlement":
			if err := func() error {
				s.RecipientSettlement.Reset()
				if err := s.RecipientSettlement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recipientSettlement\"")
			}
		case "requestedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RequestedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestedAt\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subTransfers":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.SubTransfers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SubTransfers = append(s.SubTransfers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subTransfers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b01110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransferRequest) {
					name = jsonFieldsNameOfTransferRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferRequestDestinationType as json.
func (s TransferRequestDestinationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferRequestDestinationType from json.
func (s *TransferRequestDestinationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferRequestDestinationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferRequestDestinationType(v) {
	case TransferRequestDestinationTypeSYSTEMBANKACCOUNT:
		*s = TransferRequestDestinationTypeSYSTEMBANKACCOUNT
	case TransferRequestDestinationTypeEXTERNALBANKACCOUNT:
		*s = TransferRequestDestinationTypeEXTERNALBANKACCOUNT
	case TransferRequestDestinationTypeORIGINALTRANSFERSOURCE:
		*s = TransferRequestDestinationTypeORIGINALTRANSFERSOURCE
	default:
		*s = TransferRequestDestinationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferRequestDestinationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferRequestDestinationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferRequestTo as json.
func (s TransferRequestTo) Encode(e *jx.Encoder) {
	switch s.Type {
	case BankAccountDestinationTransferRequestTo:
		s.BankAccountDestination.Encode(e)
	case OriginalTransferSourceAsDestinationTransferRequestTo:
		s.OriginalTransferSourceAsDestination.Encode(e)
	}
}

func (s TransferRequestTo) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case BankAccountDestinationTransferRequestTo:
		s.BankAccountDestination.encodeFields(e)
	case OriginalTransferSourceAsDestinationTransferRequestTo:
		s.OriginalTransferSourceAsDestination.encodeFields(e)
	}
}

// Decode decodes TransferRequestTo from json.
func (s *TransferRequestTo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferRequestTo to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "bankAccountNumber":
				match := BankAccountDestinationTransferRequestTo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "bankAccountHolder":
				match := BankAccountDestinationTransferRequestTo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "bankAccountHolderAccountId":
				match := BankAccountDestinationTransferRequestTo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "bankName":
				match := BankAccountDestinationTransferRequestTo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "bankSwiftCode":
				match := BankAccountDestinationTransferRequestTo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "bankAccountType":
				match := BankAccountDestinationTransferRequestTo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "recordId":
				match := OriginalTransferSourceAsDestinationTransferRequestTo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "details":
				match := OriginalTransferSourceAsDestinationTransferRequestTo
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case BankAccountDestinationTransferRequestTo:
		if err := s.BankAccountDestination.Decode(d); err != nil {
			return err
		}
	case OriginalTransferSourceAsDestinationTransferRequestTo:
		if err := s.OriginalTransferSourceAsDestination.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferRequestTo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferRequestTo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateWithdrawalAmlStatusDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateWithdrawalAmlStatusDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("withdrawalId")
		e.Str(s.WithdrawalId)
	}
	{
		e.FieldStart("amlStatus")
		e.Str(s.AmlStatus)
	}
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
	{
		e.FieldStart("updatedBy")
		e.Str(s.UpdatedBy)
	}
}

var jsonFieldsNameOfUpdateWithdrawalAmlStatusDto = [4]string{
	0: "withdrawalId",
	1: "amlStatus",
	2: "comment",
	3: "updatedBy",
}

// Decode decodes UpdateWithdrawalAmlStatusDto from json.
func (s *UpdateWithdrawalAmlStatusDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWithdrawalAmlStatusDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "withdrawalId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WithdrawalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"withdrawalId\"")
			}
		case "amlStatus":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AmlStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amlStatus\"")
			}
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "updatedBy":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UpdatedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateWithdrawalAmlStatusDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateWithdrawalAmlStatusDto) {
					name = jsonFieldsNameOfUpdateWithdrawalAmlStatusDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWithdrawalAmlStatusDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWithdrawalAmlStatusDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WithdrawalRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WithdrawalRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("portfolioId")
		e.Str(s.PortfolioId)
	}
}

var jsonFieldsNameOfWithdrawalRequestDto = [2]string{
	0: "amount",
	1: "portfolioId",
}

// Decode decodes WithdrawalRequestDto from json.
func (s *WithdrawalRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WithdrawalRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "amount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "portfolioId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PortfolioId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"portfolioId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WithdrawalRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWithdrawalRequestDto) {
					name = jsonFieldsNameOfWithdrawalRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WithdrawalRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WithdrawalRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Code generated by ogen, DO NOT EDIT.

package fundingsdk

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AnonymizationControllerAnonymizePii invokes AnonymizationController_anonymizePii operation.
	//
	// Endpoint to anonymize data on funding server.
	//
	// POST /restricted/anonymize-pii
	AnonymizationControllerAnonymizePii(ctx context.Context, request *AnonymizePiiRequestDTO) error
	// CustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBank invokes CustomerBankWhitelistInternalController_createWhitelistedCustomerBank operation.
	//
	// POST /internal/v1/whitelisted-customer-banks
	CustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBank(ctx context.Context, request *CreateWhitelistedCustomerBankRequestDto) error
	// CustomerBanksExternalControllerV1GetCustomerBanks invokes CustomerBanksExternalControllerV1_getCustomerBanks operation.
	//
	// Endpoint to get customer banks.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /external/v1/customer-banks
	CustomerBanksExternalControllerV1GetCustomerBanks(ctx context.Context, params CustomerBanksExternalControllerV1GetCustomerBanksParams) ([]CustomerBankDto, error)
	// CustomerBanksExternalControllerV2GetCustomerBanksV2 invokes CustomerBanksExternalControllerV2_getCustomerBanksV2 operation.
	//
	// Endpoint to get customer banks.
	//
	// GET /external/v2/customer-banks
	CustomerBanksExternalControllerV2GetCustomerBanksV2(ctx context.Context, params CustomerBanksExternalControllerV2GetCustomerBanksV2Params) ([]CustomerBankDto, error)
	// CustomerBanksExternalControllerV2GetCustomerBanksV2Unmasked invokes CustomerBanksExternalControllerV2_getCustomerBanksV2Unmasked operation.
	//
	// Endpoint to get customer banks with bank account number unmasked.
	//
	// GET /external/v2/customer-banks/unmasked
	CustomerBanksExternalControllerV2GetCustomerBanksV2Unmasked(ctx context.Context, params CustomerBanksExternalControllerV2GetCustomerBanksV2UnmaskedParams) ([]CustomerBankDto, error)
	// CustomerBanksInternalControllerGetWithdrawalCustomerBank invokes CustomerBanksInternalController_getWithdrawalCustomerBank operation.
	//
	// GET /internal/v1/customer-banks/account-uuid/{accountUuid}/banks/{bankId}
	CustomerBanksInternalControllerGetWithdrawalCustomerBank(ctx context.Context, params CustomerBanksInternalControllerGetWithdrawalCustomerBankParams) error
	// DDBanksExternalControllerGetBankMandateSetupURL invokes DDBanksExternalController_getBankMandateSetupURL operation.
	//
	// Endpoint to generate a Mandate URL for a specific bank code and customer reference.
	//
	// GET /external/v1/directdebit/banks/generate-mandate-url/{applicantBankCode}
	DDBanksExternalControllerGetBankMandateSetupURL(ctx context.Context, params DDBanksExternalControllerGetBankMandateSetupURLParams) error
	// DDBanksInternalControllerCreateCustomerBank invokes DDBanksInternalController_createCustomerBank operation.
	//
	// POST /v1/directdebit/banks/create-customer-bank
	DDBanksInternalControllerCreateCustomerBank(ctx context.Context, request *CreateDdCustomerBankDto) error
	// DDBanksInternalControllerGetBankMandateCancellationURL invokes DDBanksInternalController_getBankMandateCancellationURL operation.
	//
	// GET /v1/directdebit/banks/generate-mandate-cancellation-url/{applicantBankCode}
	DDBanksInternalControllerGetBankMandateCancellationURL(ctx context.Context, params DDBanksInternalControllerGetBankMandateCancellationURLParams) error
	// DDBanksInternalControllerGetBankMandateSetupURL invokes DDBanksInternalController_getBankMandateSetupURL operation.
	//
	// Endpoint to generate a Mandate URL for a specific bank code and customer reference.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /v1/directdebit/banks/generate-mandate-url/{applicantBankCode}
	DDBanksInternalControllerGetBankMandateSetupURL(ctx context.Context, params DDBanksInternalControllerGetBankMandateSetupURLParams) error
	// DDBanksInternalControllerGetBanks invokes DDBanksInternalController_getBanks operation.
	//
	// GET /v1/directdebit/banks
	DDBanksInternalControllerGetBanks(ctx context.Context) error
	// DDBanksInternalControllerGetMandateStatus invokes DDBanksInternalController_getMandateStatus operation.
	//
	// GET /v1/directdebit/banks/mandate-status/{boTransactionRefNo}
	DDBanksInternalControllerGetMandateStatus(ctx context.Context, params DDBanksInternalControllerGetMandateStatusParams) error
	// DDBanksInternalControllerSendEDDACreation invokes DDBanksInternalController_sendEDDACreation operation.
	//
	// POST /v1/directdebit/banks/send-edda-creation
	DDBanksInternalControllerSendEDDACreation(ctx context.Context) error
	// DDBanksInternalControllerTestConnectivity invokes DDBanksInternalController_testConnectivity operation.
	//
	// POST /v1/directdebit/banks/test-connectivity
	DDBanksInternalControllerTestConnectivity(ctx context.Context) error
	// DepositRecordsInternalControllerGetDepositRecords invokes DepositRecordsInternalController_getDepositRecords operation.
	//
	// POST /int/v1/deposits/records/find
	DepositRecordsInternalControllerGetDepositRecords(ctx context.Context, request *DepositRecordsInternalControllerGetDepositRecordsReq) ([]FundDepositRecordDto, error)
	// DepositRecordsInternalControllerGetDepositRecordsByAccount invokes DepositRecordsInternalController_getDepositRecordsByAccount operation.
	//
	// GET /int/v1/deposits/records/account/{accountUuid}
	DepositRecordsInternalControllerGetDepositRecordsByAccount(ctx context.Context, params DepositRecordsInternalControllerGetDepositRecordsByAccountParams) ([]FundDepositRecordDto, error)
	// DepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuid invokes DepositRequestsInternalController_getCustomerBankByDepositRequestFundDepositUuid operation.
	//
	// GET /internal/v1/deposit-requests/fund-deposit-uuid/{fundDepositUuid}/customer-bank
	DepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuid(ctx context.Context, params DepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuidParams) error
	// DepositRequestsInternalControllerGetDepositHistory invokes DepositRequestsInternalController_getDepositHistory operation.
	//
	// GET /internal/v1/deposit-requests/history
	DepositRequestsInternalControllerGetDepositHistory(ctx context.Context, params DepositRequestsInternalControllerGetDepositHistoryParams) error
	// DepositSchedulesExternalControllerCreateDepositSchedule invokes DepositSchedulesExternalController_createDepositSchedule operation.
	//
	// Endpoint create a new DepositSchedule.
	//
	// POST /external/v1/deposit-schedules
	DepositSchedulesExternalControllerCreateDepositSchedule(ctx context.Context, request *CreateDepositScheduleRequestDto, params DepositSchedulesExternalControllerCreateDepositScheduleParams) (*DepositScheduleDto, error)
	// DepositSchedulesExternalControllerGetDepositScheduleByPersistentUuid invokes DepositSchedulesExternalController_getDepositScheduleByPersistentUuid operation.
	//
	// Endpoint get a DepositSchedule by persistent uuid.
	//
	// GET /external/v1/deposit-schedules/{persistentUuid}
	DepositSchedulesExternalControllerGetDepositScheduleByPersistentUuid(ctx context.Context, params DepositSchedulesExternalControllerGetDepositScheduleByPersistentUuidParams) (*DepositScheduleView, error)
	// DepositSchedulesExternalControllerGetDepositSchedules invokes DepositSchedulesExternalController_getDepositSchedules operation.
	//
	// Endpoint to get ACTIVE and IN_PROGRESS deposit schedules for customer.
	//
	// GET /external/v1/deposit-schedules
	DepositSchedulesExternalControllerGetDepositSchedules(ctx context.Context) ([]DepositScheduleView, error)
	// DepositSchedulesExternalControllerSoftDeleteDepositSchedule invokes DepositSchedulesExternalController_softDeleteDepositSchedule operation.
	//
	// Endpoint removes a DepositSchedule for persistent uuid.
	//
	// DELETE /external/v1/deposit-schedules/{persistentUuid}
	DepositSchedulesExternalControllerSoftDeleteDepositSchedule(ctx context.Context, params DepositSchedulesExternalControllerSoftDeleteDepositScheduleParams) error
	// DepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFAST invokes DepositSchedulesExternalController_updateAllDepositSchedulesInCustomerBankToFAST operation.
	//
	// Endpoint to update all deposit schedules that are using the old SGDD bank to the new FAST bank for
	// customer.
	//
	// POST /external/v1/deposit-schedules/fastify
	DepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFAST(ctx context.Context, request *FastifyDepositScheduleDto) ([]DepositScheduleView, error)
	// DepositSchedulesExternalControllerUpdateDepositSchedule invokes DepositSchedulesExternalController_updateDepositSchedule operation.
	//
	// Endpoint recreates a DepositSchedule for persistent uuid.
	//
	// PUT /external/v1/deposit-schedules/{persistentUuid}
	DepositSchedulesExternalControllerUpdateDepositSchedule(ctx context.Context, request *CreateDepositScheduleRequestDto, params DepositSchedulesExternalControllerUpdateDepositScheduleParams) (*DepositScheduleView, error)
	// DepositSchedulesInternalControllerCreateDepositSchedule invokes DepositSchedulesInternalController_createDepositSchedule operation.
	//
	// Endpoint to create a new DepositSchedule.
	//
	// POST /int/v1/deposit-schedules
	DepositSchedulesInternalControllerCreateDepositSchedule(ctx context.Context, request *CreateDepositScheduleDto) (*DepositScheduleDto, error)
	// DepositSchedulesInternalControllerFastify invokes DepositSchedulesInternalController_fastify operation.
	//
	// Endpoint to bulk migrate old SGDD deposit schedules to FAST.
	//
	// POST /int/v1/deposit-schedules/fastify
	DepositSchedulesInternalControllerFastify(ctx context.Context, request *FastifyDepositScheduleInternalDto) error
	// DepositSchedulesInternalControllerSoftDeleteDepositSchedule invokes DepositSchedulesInternalController_softDeleteDepositSchedule operation.
	//
	// Soft delete a deposit schedule.
	//
	// DELETE /int/v1/deposit-schedules
	DepositSchedulesInternalControllerSoftDeleteDepositSchedule(ctx context.Context, request *SoftDeleteDepositScheduleRequestDto) error
	// EddaCallbackExternalControllerCreationCallback invokes EddaCallbackExternalController_creationCallback operation.
	//
	// POST /external/edda/api/v1/edda/callback/creation
	EddaCallbackExternalControllerCreationCallback(ctx context.Context) error
	// EddaCallbackExternalControllerMandateCancellationCallback invokes EddaCallbackExternalController_mandateCancellationCallback operation.
	//
	// POST /external/edda/api/v1/edda/callback/cancellation
	EddaCallbackExternalControllerMandateCancellationCallback(ctx context.Context, request *CancellationCallbackDto) error
	// EddaCallbackExternalControllerSubmitResponseCallback invokes EddaCallbackExternalController_submitResponseCallback operation.
	//
	// POST /external/edda/api/v1/edda/submitResponse
	EddaCallbackExternalControllerSubmitResponseCallback(ctx context.Context) error
	// FailedDepositSplitsExternalControllerGetFailedDepositSplitsForCustomer invokes FailedDepositSplitsExternalController_getFailedDepositSplitsForCustomer operation.
	//
	// Endpoint to get failed deposit splits for customer.
	//
	// GET /external/v1/failed-deposit-splits
	FailedDepositSplitsExternalControllerGetFailedDepositSplitsForCustomer(ctx context.Context) ([]FailedDepositSplitsForAccountDTO, error)
	// FastExternalControllerDeleteCustomerBank invokes FastExternalController_deleteCustomerBank operation.
	//
	// Endpoint to delete bank by id.
	//
	// DELETE /external/v1/fast/customer-banks/{id}
	FastExternalControllerDeleteCustomerBank(ctx context.Context, params FastExternalControllerDeleteCustomerBankParams) (*CustomerBankDto, error)
	// FastExternalControllerGetRetailBankList invokes FastExternalController_getRetailBankList operation.
	//
	// Endpoint to get all retail banks from ACME.
	//
	// GET /external/v1/fast/banks
	FastExternalControllerGetRetailBankList(ctx context.Context, params FastExternalControllerGetRetailBankListParams) error
	// FastExternalControllerInitFASTMandateSetup invokes FastExternalController_initFASTMandateSetup operation.
	//
	// Endpoint to init mandate setup and return mandate url for user.
	//
	// POST /external/v1/fast/banks/init-mandate-setup
	FastExternalControllerInitFASTMandateSetup(ctx context.Context, request *InitMandateSetupRequestDTO, params FastExternalControllerInitFASTMandateSetupParams) error
	// HealthControllerGetEddaHealth invokes HealthController_getEddaHealth operation.
	//
	// GET /external/edda/health
	HealthControllerGetEddaHealth(ctx context.Context) error
	// HealthControllerGetExternalHealth invokes HealthController_getExternalHealth operation.
	//
	// Endpoint to check the health of the service for api-gateway.
	//
	// GET /external/health
	HealthControllerGetExternalHealth(ctx context.Context) error
	// HealthControllerGetHealth invokes HealthController_getHealth operation.
	//
	// Endpoint to check the health of the service for liveness probe.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /health
	HealthControllerGetHealth(ctx context.Context) error
	// IntergoalTransferRequestExternalControllerCreateIntergoalTransferRequest invokes IntergoalTransferRequestExternalController_createIntergoalTransferRequest operation.
	//
	// Starts IGTRequest Workflow.
	//
	// POST /external/v1/intergoal-transfer-request
	IntergoalTransferRequestExternalControllerCreateIntergoalTransferRequest(ctx context.Context, request *StartIGTRequestWorkflowExternalRequestDTO, params IntergoalTransferRequestExternalControllerCreateIntergoalTransferRequestParams) (*StartIGTRequestWorkflowSuccessResponseDTO, error)
	// IntergoalTransferRequestExternalControllerGetIntergoalTransfersDuration invokes IntergoalTransferRequestExternalController_getIntergoalTransfersDuration operation.
	//
	// Get IGT duration.
	//
	// GET /external/v1/intergoal-transfer-request/duration
	IntergoalTransferRequestExternalControllerGetIntergoalTransfersDuration(ctx context.Context, params IntergoalTransferRequestExternalControllerGetIntergoalTransfersDurationParams) error
	// IntergoalTransferRequestInternalControllerCancel invokes IntergoalTransferRequestInternalController_cancel operation.
	//
	// Cancels an Intergoal Transfer Request.
	//
	// POST /internal/v1/intergoal-transfer-request/{id}/cancel
	IntergoalTransferRequestInternalControllerCancel(ctx context.Context, request *CancelIntergoalTransferDTO, params IntergoalTransferRequestInternalControllerCancelParams) error
	// IntergoalTransferRequestInternalControllerCreateIntergoalTransferRequest invokes IntergoalTransferRequestInternalController_createIntergoalTransferRequest operation.
	//
	// Starts IGTRequest Workflow.
	//
	// POST /internal/v1/intergoal-transfer-request
	IntergoalTransferRequestInternalControllerCreateIntergoalTransferRequest(ctx context.Context, request *StartIGTRequestWorkflowRequestDTO) (*StartIGTRequestWorkflowSuccessResponseDTO, error)
	// IntergoalTransferRequestInternalControllerGetIGTSchedules invokes IntergoalTransferRequestInternalController_getIGTSchedules operation.
	//
	// Get all IGT schedules by userId.
	//
	// GET /internal/v1/intergoal-transfer-request/schedules
	IntergoalTransferRequestInternalControllerGetIGTSchedules(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIGTSchedulesParams) (IntergoalTransferRequestInternalControllerGetIGTSchedulesRes, error)
	// IntergoalTransferRequestInternalControllerGetIntergoalTransfersDuration invokes IntergoalTransferRequestInternalController_getIntergoalTransfersDuration operation.
	//
	// Get IGT duration.
	//
	// GET /internal/v1/intergoal-transfer-request/duration
	IntergoalTransferRequestInternalControllerGetIntergoalTransfersDuration(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIntergoalTransfersDurationParams) error
	// IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuid invokes IntergoalTransferRequestInternalController_getIntergoalTransfersRequestByAccountUuid operation.
	//
	// Get all IGT for an account.
	//
	// GET /internal/v1/intergoal-transfer-request
	IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuid(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidParams) (IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidRes, error)
	// LeanExternalControllerCancelPaymentIntent invokes LeanExternalController_cancelPaymentIntent operation.
	//
	// Endpoint to cancel payment intent.
	//
	// POST /external/v1/lean/payment-intents/{paymentIntentId}/cancel
	LeanExternalControllerCancelPaymentIntent(ctx context.Context, request *LeanPaymentIntentCancelInputDto, params LeanExternalControllerCancelPaymentIntentParams) (*GetLeanCustomerDto, error)
	// LeanExternalControllerCreateInstantPaymentIntent invokes LeanExternalController_createInstantPaymentIntent operation.
	//
	// Endpoint to create an instant payment intent.
	//
	// POST /external/v1/lean/payment-intents
	LeanExternalControllerCreateInstantPaymentIntent(ctx context.Context, request *LeanPaymentIntentInputDto) (*LeanPaymentIntentDto, error)
	// LeanExternalControllerCreateLeanToken invokes LeanExternalController_createLeanToken operation.
	//
	// Endpoint to create Lean Token for account id.
	//
	// POST /external/v1/lean/token
	LeanExternalControllerCreateLeanToken(ctx context.Context) (*GetLeanTokenDto, error)
	// LeanExternalControllerCreatePaymentIntentForSchedule invokes LeanExternalController_createPaymentIntentForSchedule operation.
	//
	// Endpoint to create a deposit request and payment intent for deposit schedule.
	//
	// POST /external/v1/lean/scheduled-payment-intents
	LeanExternalControllerCreatePaymentIntentForSchedule(ctx context.Context, request *LeanScheduledPaymentIntentInputDto) (*LeanPaymentIntentDto, error)
	// LeanExternalControllerGetBanksConnectStatus invokes LeanExternalController_getBanksConnectStatus operation.
	//
	// Get status of connecting to banks.
	//
	// GET /external/v1/lean/banks/connect-status
	LeanExternalControllerGetBanksConnectStatus(ctx context.Context, params LeanExternalControllerGetBanksConnectStatusParams) (*BanksConnectStatusResponseDto, error)
	// LeanExternalControllerGetOrCreateLeanCustomer invokes LeanExternalController_getOrCreateLeanCustomer operation.
	//
	// Endpoint to get LeanCustomer for account id.
	//
	// POST /external/v1/lean/customers
	LeanExternalControllerGetOrCreateLeanCustomer(ctx context.Context) (*GetLeanCustomerDto, error)
	// LeanInternalControllerGetLeanUserByAccountUuid invokes LeanInternalController_getLeanUserByAccountUuid operation.
	//
	// Endpoint to get LEAN customer.
	//
	// GET /internal/v1/lean/user/{accountUuid}
	LeanInternalControllerGetLeanUserByAccountUuid(ctx context.Context, params LeanInternalControllerGetLeanUserByAccountUuidParams) (*LeanCustomer, error)
	// LeanInternalControllerTestConnectivity invokes LeanInternalController_testConnectivity operation.
	//
	// Endpoint to test connectivity with Lean.
	//
	// POST /internal/v1/lean/test-connectivity
	LeanInternalControllerTestConnectivity(ctx context.Context) error
	// LeanInternalControllerUnlinkBank invokes LeanInternalController_unlinkBank operation.
	//
	// Endpoint to unlink bank by customer request.
	//
	// POST /internal/v1/lean/banks/unlink
	LeanInternalControllerUnlinkBank(ctx context.Context, request *LeanUnlinkBankDto) error
	// LocalBanksControllerGetLocalBanks invokes LocalBanksController_getLocalBanks operation.
	//
	// GET /v1/local-banks
	LocalBanksControllerGetLocalBanks(ctx context.Context) error
	// MockAbsBankControllerFakeMandateCreationUrl invokes MockAbsBankController_fakeMandateCreationUrl operation.
	//
	// GET /v1/mock-bank/mandate-creation-url
	MockAbsBankControllerFakeMandateCreationUrl(ctx context.Context, params MockAbsBankControllerFakeMandateCreationUrlParams) error
	// PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovements invokes PortfoliosExternalControllerV1_getRecentAndInProgressAccountMoneyMovements operation.
	//
	// Endpoint to get money movement with timeline.
	//
	// GET /external/v1/portfolios/money-movements
	PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovementsParams) error
	// PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2 invokes PortfoliosExternalControllerV2_getRecentAndInProgressAccountMoneyMovementsV2 operation.
	//
	// Endpoint to get money movement with timeline.
	//
	// GET /external/v2/portfolios/money-movements
	PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2(ctx context.Context, params PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2Params) error
	// PortfoliosInternalControllerV1GetMoneyMovements invokes PortfoliosInternalControllerV1_getMoneyMovements operation.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /internal/v1/portfolios/{portfolioId}/money-movements
	PortfoliosInternalControllerV1GetMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV1GetMoneyMovementsParams) error
	// PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovements invokes PortfoliosInternalControllerV1_getRecentAndInProgressAccountMoneyMovements operation.
	//
	// Endpoint to get money movement with timeline for a given account.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /internal/v1/portfolios/money-movements
	PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovementsParams) error
	// PortfoliosInternalControllerV2GetMoneyMovementsV2 invokes PortfoliosInternalControllerV2_getMoneyMovementsV2 operation.
	//
	// GET /internal/v2/portfolios/{portfolioId}/money-movements
	PortfoliosInternalControllerV2GetMoneyMovementsV2(ctx context.Context, params PortfoliosInternalControllerV2GetMoneyMovementsV2Params) error
	// PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovements invokes PortfoliosInternalControllerV2_getRecentAndInProgressAccountMoneyMovements operation.
	//
	// Endpoint to get money movement with timeline for a given account.
	//
	// GET /internal/v2/portfolios/money-movements
	PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovementsParams) error
	// SrsInternalControllerGetSrsTransferRequestWithSubtransfers invokes SrsInternalController_getSrsTransferRequestWithSubtransfers operation.
	//
	// Endpoint to fetch SRS transfer requests and their sub transfers.
	//
	// GET /internal/v1/srs/requests/{transferRequestId}/subTransfers
	SrsInternalControllerGetSrsTransferRequestWithSubtransfers(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestWithSubtransfersParams) (*SrsTransferRequestSubtransfers, error)
	// SrsInternalControllerGetSrsTransferRequests invokes SrsInternalController_getSrsTransferRequests operation.
	//
	// Endpoint to fetch SRS transfer requests.
	//
	// GET /internal/v1/srs/requests
	SrsInternalControllerGetSrsTransferRequests(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestsParams) ([]TransferRequest, error)
	// SrsInternalControllerGetSrsTransferRequestsWithSubTransfers invokes SrsInternalController_getSrsTransferRequestsWithSubTransfers operation.
	//
	// Endpoint to fetch SRS transfer requests and their sub transfers.
	//
	// GET /internal/v1/srs/subTransfers
	SrsInternalControllerGetSrsTransferRequestsWithSubTransfers(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestsWithSubTransfersParams) ([]SrsTransferRequestSubtransfers, error)
	// WithdrawalsExternalControllerGetWithdrawalById invokes WithdrawalsExternalController_getWithdrawalById operation.
	//
	// Retrieves a withdrawal record by its UUID.
	//
	// GET /external/v1/transactions/withdrawal/{uuid}
	WithdrawalsExternalControllerGetWithdrawalById(ctx context.Context, params WithdrawalsExternalControllerGetWithdrawalByIdParams) (WithdrawalsExternalControllerGetWithdrawalByIdRes, error)
	// WithdrawalsExternalControllerListWithdrawalsByAccount invokes WithdrawalsExternalController_listWithdrawalsByAccount operation.
	//
	// Retrieves withdrawal records for a specific account with pagination support.
	//
	// GET /external/v1/transactions/withdrawal
	WithdrawalsExternalControllerListWithdrawalsByAccount(ctx context.Context, params WithdrawalsExternalControllerListWithdrawalsByAccountParams) (WithdrawalsExternalControllerListWithdrawalsByAccountRes, error)
	// WithdrawalsExternalControllerSubmitWithdrawalRequests invokes WithdrawalsExternalController_submitWithdrawalRequests operation.
	//
	// POST /external/v1/transactions/withdrawal/submit
	WithdrawalsExternalControllerSubmitWithdrawalRequests(ctx context.Context, request *ExternalSubmitWithdrawalRequestsInputDto) (*SubmitWithdrawalRequestsResponseDto, error)
	// WithdrawalsInternalControllerAllowedCurrencies invokes WithdrawalsInternalController_allowedCurrencies operation.
	//
	// GET /internal/v1/transactions/withdrawal/allowed-currencies/{userId}
	WithdrawalsInternalControllerAllowedCurrencies(ctx context.Context, params WithdrawalsInternalControllerAllowedCurrenciesParams) ([]string, error)
	// WithdrawalsInternalControllerBatchApproveFlaggedWithdrawals invokes WithdrawalsInternalController_batchApproveFlaggedWithdrawals operation.
	//
	// POST /internal/v1/transactions/withdrawal/batch-approve-flagged-withdrawals
	WithdrawalsInternalControllerBatchApproveFlaggedWithdrawals(ctx context.Context, request *BatchWithdrawalApprovalInputDto) (*BatchWithdrawalApprovalResponseDto, error)
	// WithdrawalsInternalControllerCreateWithdrawal invokes WithdrawalsInternalController_createWithdrawal operation.
	//
	// Creates a new withdrawal record with the provided details. This endpoint is just creating the
	// entity (should only be called by withdrawal workflow).
	//
	// POST /internal/v1/transactions/withdrawal
	WithdrawalsInternalControllerCreateWithdrawal(ctx context.Context, request *CreateWithdrawalBodyInternalDTO) (WithdrawalsInternalControllerCreateWithdrawalRes, error)
	// WithdrawalsInternalControllerGetWithdrawalById invokes WithdrawalsInternalController_getWithdrawalById operation.
	//
	// Retrieves a withdrawal record by its UUID.
	//
	// GET /internal/v1/transactions/withdrawal/{uuid}
	WithdrawalsInternalControllerGetWithdrawalById(ctx context.Context, params WithdrawalsInternalControllerGetWithdrawalByIdParams) (WithdrawalsInternalControllerGetWithdrawalByIdRes, error)
	// WithdrawalsInternalControllerListWithdrawalsByAccount invokes WithdrawalsInternalController_listWithdrawalsByAccount operation.
	//
	// Retrieves withdrawal records for a specific account with pagination support.
	//
	// GET /internal/v1/transactions/withdrawal
	WithdrawalsInternalControllerListWithdrawalsByAccount(ctx context.Context, params WithdrawalsInternalControllerListWithdrawalsByAccountParams) (WithdrawalsInternalControllerListWithdrawalsByAccountRes, error)
	// WithdrawalsInternalControllerSubmitWithdrawalRequests invokes WithdrawalsInternalController_submitWithdrawalRequests operation.
	//
	// POST /internal/v1/transactions/withdrawal/submit
	WithdrawalsInternalControllerSubmitWithdrawalRequests(ctx context.Context, request *InternalSubmitWithdrawalRequestsInputDto) (*SubmitWithdrawalRequestsResponseDto, error)
	// WithdrawalsInternalControllerUpdateAMLStatus invokes WithdrawalsInternalController_updateAMLStatus operation.
	//
	// POST /internal/v1/transactions/withdrawal/update-aml-status
	WithdrawalsInternalControllerUpdateAMLStatus(ctx context.Context, request *UpdateWithdrawalAmlStatusDto) error
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AnonymizationControllerAnonymizePii invokes AnonymizationController_anonymizePii operation.
//
// Endpoint to anonymize data on funding server.
//
// POST /restricted/anonymize-pii
func (c *Client) AnonymizationControllerAnonymizePii(ctx context.Context, request *AnonymizePiiRequestDTO) error {
	_, err := c.sendAnonymizationControllerAnonymizePii(ctx, request)
	return err
}

func (c *Client) sendAnonymizationControllerAnonymizePii(ctx context.Context, request *AnonymizePiiRequestDTO) (res *AnonymizationControllerAnonymizePiiNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/restricted/anonymize-pii"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAnonymizationControllerAnonymizePiiRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAnonymizationControllerAnonymizePiiResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBank invokes CustomerBankWhitelistInternalController_createWhitelistedCustomerBank operation.
//
// POST /internal/v1/whitelisted-customer-banks
func (c *Client) CustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBank(ctx context.Context, request *CreateWhitelistedCustomerBankRequestDto) error {
	_, err := c.sendCustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBank(ctx, request)
	return err
}

func (c *Client) sendCustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBank(ctx context.Context, request *CreateWhitelistedCustomerBankRequestDto) (res *CustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBankCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/whitelisted-customer-banks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBankRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCustomerBankWhitelistInternalControllerCreateWhitelistedCustomerBankResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CustomerBanksExternalControllerV1GetCustomerBanks invokes CustomerBanksExternalControllerV1_getCustomerBanks operation.
//
// Endpoint to get customer banks.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /external/v1/customer-banks
func (c *Client) CustomerBanksExternalControllerV1GetCustomerBanks(ctx context.Context, params CustomerBanksExternalControllerV1GetCustomerBanksParams) ([]CustomerBankDto, error) {
	res, err := c.sendCustomerBanksExternalControllerV1GetCustomerBanks(ctx, params)
	return res, err
}

func (c *Client) sendCustomerBanksExternalControllerV1GetCustomerBanks(ctx context.Context, params CustomerBanksExternalControllerV1GetCustomerBanksParams) (res []CustomerBankDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/customer-banks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "withLastUsed" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withLastUsed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.BoolToString(params.WithLastUsed))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withDeleted" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withDeleted",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.BoolToString(params.WithDeleted))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "accountType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accountType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AccountType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CustomerBanksExternalControllerV1GetCustomerBanksOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCustomerBanksExternalControllerV1GetCustomerBanksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CustomerBanksExternalControllerV2GetCustomerBanksV2 invokes CustomerBanksExternalControllerV2_getCustomerBanksV2 operation.
//
// Endpoint to get customer banks.
//
// GET /external/v2/customer-banks
func (c *Client) CustomerBanksExternalControllerV2GetCustomerBanksV2(ctx context.Context, params CustomerBanksExternalControllerV2GetCustomerBanksV2Params) ([]CustomerBankDto, error) {
	res, err := c.sendCustomerBanksExternalControllerV2GetCustomerBanksV2(ctx, params)
	return res, err
}

func (c *Client) sendCustomerBanksExternalControllerV2GetCustomerBanksV2(ctx context.Context, params CustomerBanksExternalControllerV2GetCustomerBanksV2Params) (res []CustomerBankDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v2/customer-banks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "withLastUsed" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withLastUsed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithLastUsed.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withDeleted" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withDeleted",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithDeleted.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "accountType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accountType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AccountType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CustomerBanksExternalControllerV2GetCustomerBanksV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCustomerBanksExternalControllerV2GetCustomerBanksV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CustomerBanksExternalControllerV2GetCustomerBanksV2Unmasked invokes CustomerBanksExternalControllerV2_getCustomerBanksV2Unmasked operation.
//
// Endpoint to get customer banks with bank account number unmasked.
//
// GET /external/v2/customer-banks/unmasked
func (c *Client) CustomerBanksExternalControllerV2GetCustomerBanksV2Unmasked(ctx context.Context, params CustomerBanksExternalControllerV2GetCustomerBanksV2UnmaskedParams) ([]CustomerBankDto, error) {
	res, err := c.sendCustomerBanksExternalControllerV2GetCustomerBanksV2Unmasked(ctx, params)
	return res, err
}

func (c *Client) sendCustomerBanksExternalControllerV2GetCustomerBanksV2Unmasked(ctx context.Context, params CustomerBanksExternalControllerV2GetCustomerBanksV2UnmaskedParams) (res []CustomerBankDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v2/customer-banks/unmasked"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "withLastUsed" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withLastUsed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithLastUsed.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "withDeleted" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withDeleted",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithDeleted.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "accountType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accountType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AccountType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, CustomerBanksExternalControllerV2GetCustomerBanksV2UnmaskedOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCustomerBanksExternalControllerV2GetCustomerBanksV2UnmaskedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CustomerBanksInternalControllerGetWithdrawalCustomerBank invokes CustomerBanksInternalController_getWithdrawalCustomerBank operation.
//
// GET /internal/v1/customer-banks/account-uuid/{accountUuid}/banks/{bankId}
func (c *Client) CustomerBanksInternalControllerGetWithdrawalCustomerBank(ctx context.Context, params CustomerBanksInternalControllerGetWithdrawalCustomerBankParams) error {
	_, err := c.sendCustomerBanksInternalControllerGetWithdrawalCustomerBank(ctx, params)
	return err
}

func (c *Client) sendCustomerBanksInternalControllerGetWithdrawalCustomerBank(ctx context.Context, params CustomerBanksInternalControllerGetWithdrawalCustomerBankParams) (res *CustomerBanksInternalControllerGetWithdrawalCustomerBankOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/internal/v1/customer-banks/account-uuid/"
	{
		// Encode "accountUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "accountUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/banks/"
	{
		// Encode "bankId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "bankId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BankId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCustomerBanksInternalControllerGetWithdrawalCustomerBankResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DDBanksExternalControllerGetBankMandateSetupURL invokes DDBanksExternalController_getBankMandateSetupURL operation.
//
// Endpoint to generate a Mandate URL for a specific bank code and customer reference.
//
// GET /external/v1/directdebit/banks/generate-mandate-url/{applicantBankCode}
func (c *Client) DDBanksExternalControllerGetBankMandateSetupURL(ctx context.Context, params DDBanksExternalControllerGetBankMandateSetupURLParams) error {
	_, err := c.sendDDBanksExternalControllerGetBankMandateSetupURL(ctx, params)
	return err
}

func (c *Client) sendDDBanksExternalControllerGetBankMandateSetupURL(ctx context.Context, params DDBanksExternalControllerGetBankMandateSetupURLParams) (res *DDBanksExternalControllerGetBankMandateSetupURLOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/external/v1/directdebit/banks/generate-mandate-url/"
	{
		// Encode "applicantBankCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicantBankCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApplicantBankCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, DDBanksExternalControllerGetBankMandateSetupURLOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDDBanksExternalControllerGetBankMandateSetupURLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DDBanksInternalControllerCreateCustomerBank invokes DDBanksInternalController_createCustomerBank operation.
//
// POST /v1/directdebit/banks/create-customer-bank
func (c *Client) DDBanksInternalControllerCreateCustomerBank(ctx context.Context, request *CreateDdCustomerBankDto) error {
	_, err := c.sendDDBanksInternalControllerCreateCustomerBank(ctx, request)
	return err
}

func (c *Client) sendDDBanksInternalControllerCreateCustomerBank(ctx context.Context, request *CreateDdCustomerBankDto) (res *DDBanksInternalControllerCreateCustomerBankCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/directdebit/banks/create-customer-bank"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDDBanksInternalControllerCreateCustomerBankRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDDBanksInternalControllerCreateCustomerBankResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DDBanksInternalControllerGetBankMandateCancellationURL invokes DDBanksInternalController_getBankMandateCancellationURL operation.
//
// GET /v1/directdebit/banks/generate-mandate-cancellation-url/{applicantBankCode}
func (c *Client) DDBanksInternalControllerGetBankMandateCancellationURL(ctx context.Context, params DDBanksInternalControllerGetBankMandateCancellationURLParams) error {
	_, err := c.sendDDBanksInternalControllerGetBankMandateCancellationURL(ctx, params)
	return err
}

func (c *Client) sendDDBanksInternalControllerGetBankMandateCancellationURL(ctx context.Context, params DDBanksInternalControllerGetBankMandateCancellationURLParams) (res *DDBanksInternalControllerGetBankMandateCancellationURLOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/directdebit/banks/generate-mandate-cancellation-url/"
	{
		// Encode "applicantBankCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicantBankCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApplicantBankCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "boDDARefNo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "boDDARefNo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.BoDDARefNo))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "boTransactionRefNo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "boTransactionRefNo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.BoTransactionRefNo))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDDBanksInternalControllerGetBankMandateCancellationURLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DDBanksInternalControllerGetBankMandateSetupURL invokes DDBanksInternalController_getBankMandateSetupURL operation.
//
// Endpoint to generate a Mandate URL for a specific bank code and customer reference.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/directdebit/banks/generate-mandate-url/{applicantBankCode}
func (c *Client) DDBanksInternalControllerGetBankMandateSetupURL(ctx context.Context, params DDBanksInternalControllerGetBankMandateSetupURLParams) error {
	_, err := c.sendDDBanksInternalControllerGetBankMandateSetupURL(ctx, params)
	return err
}

func (c *Client) sendDDBanksInternalControllerGetBankMandateSetupURL(ctx context.Context, params DDBanksInternalControllerGetBankMandateSetupURLParams) (res *DDBanksInternalControllerGetBankMandateSetupURLOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/directdebit/banks/generate-mandate-url/"
	{
		// Encode "applicantBankCode" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "applicantBankCode",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApplicantBankCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDDBanksInternalControllerGetBankMandateSetupURLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DDBanksInternalControllerGetBanks invokes DDBanksInternalController_getBanks operation.
//
// GET /v1/directdebit/banks
func (c *Client) DDBanksInternalControllerGetBanks(ctx context.Context) error {
	_, err := c.sendDDBanksInternalControllerGetBanks(ctx)
	return err
}

func (c *Client) sendDDBanksInternalControllerGetBanks(ctx context.Context) (res *DDBanksInternalControllerGetBanksOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/directdebit/banks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDDBanksInternalControllerGetBanksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DDBanksInternalControllerGetMandateStatus invokes DDBanksInternalController_getMandateStatus operation.
//
// GET /v1/directdebit/banks/mandate-status/{boTransactionRefNo}
func (c *Client) DDBanksInternalControllerGetMandateStatus(ctx context.Context, params DDBanksInternalControllerGetMandateStatusParams) error {
	_, err := c.sendDDBanksInternalControllerGetMandateStatus(ctx, params)
	return err
}

func (c *Client) sendDDBanksInternalControllerGetMandateStatus(ctx context.Context, params DDBanksInternalControllerGetMandateStatusParams) (res *DDBanksInternalControllerGetMandateStatusOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/directdebit/banks/mandate-status/"
	{
		// Encode "boTransactionRefNo" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "boTransactionRefNo",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BoTransactionRefNo))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDDBanksInternalControllerGetMandateStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DDBanksInternalControllerSendEDDACreation invokes DDBanksInternalController_sendEDDACreation operation.
//
// POST /v1/directdebit/banks/send-edda-creation
func (c *Client) DDBanksInternalControllerSendEDDACreation(ctx context.Context) error {
	_, err := c.sendDDBanksInternalControllerSendEDDACreation(ctx)
	return err
}

func (c *Client) sendDDBanksInternalControllerSendEDDACreation(ctx context.Context) (res *DDBanksInternalControllerSendEDDACreationNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/directdebit/banks/send-edda-creation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDDBanksInternalControllerSendEDDACreationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DDBanksInternalControllerTestConnectivity invokes DDBanksInternalController_testConnectivity operation.
//
// POST /v1/directdebit/banks/test-connectivity
func (c *Client) DDBanksInternalControllerTestConnectivity(ctx context.Context) error {
	_, err := c.sendDDBanksInternalControllerTestConnectivity(ctx)
	return err
}

func (c *Client) sendDDBanksInternalControllerTestConnectivity(ctx context.Context) (res *DDBanksInternalControllerTestConnectivityNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/directdebit/banks/test-connectivity"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDDBanksInternalControllerTestConnectivityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositRecordsInternalControllerGetDepositRecords invokes DepositRecordsInternalController_getDepositRecords operation.
//
// POST /int/v1/deposits/records/find
func (c *Client) DepositRecordsInternalControllerGetDepositRecords(ctx context.Context, request *DepositRecordsInternalControllerGetDepositRecordsReq) ([]FundDepositRecordDto, error) {
	res, err := c.sendDepositRecordsInternalControllerGetDepositRecords(ctx, request)
	return res, err
}

func (c *Client) sendDepositRecordsInternalControllerGetDepositRecords(ctx context.Context, request *DepositRecordsInternalControllerGetDepositRecordsReq) (res []FundDepositRecordDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/int/v1/deposits/records/find"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDepositRecordsInternalControllerGetDepositRecordsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositRecordsInternalControllerGetDepositRecordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositRecordsInternalControllerGetDepositRecordsByAccount invokes DepositRecordsInternalController_getDepositRecordsByAccount operation.
//
// GET /int/v1/deposits/records/account/{accountUuid}
func (c *Client) DepositRecordsInternalControllerGetDepositRecordsByAccount(ctx context.Context, params DepositRecordsInternalControllerGetDepositRecordsByAccountParams) ([]FundDepositRecordDto, error) {
	res, err := c.sendDepositRecordsInternalControllerGetDepositRecordsByAccount(ctx, params)
	return res, err
}

func (c *Client) sendDepositRecordsInternalControllerGetDepositRecordsByAccount(ctx context.Context, params DepositRecordsInternalControllerGetDepositRecordsByAccountParams) (res []FundDepositRecordDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/int/v1/deposits/records/account/"
	{
		// Encode "accountUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "accountUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositRecordsInternalControllerGetDepositRecordsByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuid invokes DepositRequestsInternalController_getCustomerBankByDepositRequestFundDepositUuid operation.
//
// GET /internal/v1/deposit-requests/fund-deposit-uuid/{fundDepositUuid}/customer-bank
func (c *Client) DepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuid(ctx context.Context, params DepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuidParams) error {
	_, err := c.sendDepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuid(ctx, params)
	return err
}

func (c *Client) sendDepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuid(ctx context.Context, params DepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuidParams) (res *DepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuidOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/internal/v1/deposit-requests/fund-deposit-uuid/"
	{
		// Encode "fundDepositUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fundDepositUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.FundDepositUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/customer-bank"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositRequestsInternalControllerGetCustomerBankByDepositRequestFundDepositUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositRequestsInternalControllerGetDepositHistory invokes DepositRequestsInternalController_getDepositHistory operation.
//
// GET /internal/v1/deposit-requests/history
func (c *Client) DepositRequestsInternalControllerGetDepositHistory(ctx context.Context, params DepositRequestsInternalControllerGetDepositHistoryParams) error {
	_, err := c.sendDepositRequestsInternalControllerGetDepositHistory(ctx, params)
	return err
}

func (c *Client) sendDepositRequestsInternalControllerGetDepositHistory(ctx context.Context, params DepositRequestsInternalControllerGetDepositHistoryParams) (res *DepositRequestsInternalControllerGetDepositHistoryOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/deposit-requests/history"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "accountUuid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accountUuid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AccountUuid))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositRequestsInternalControllerGetDepositHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesExternalControllerCreateDepositSchedule invokes DepositSchedulesExternalController_createDepositSchedule operation.
//
// Endpoint create a new DepositSchedule.
//
// POST /external/v1/deposit-schedules
func (c *Client) DepositSchedulesExternalControllerCreateDepositSchedule(ctx context.Context, request *CreateDepositScheduleRequestDto, params DepositSchedulesExternalControllerCreateDepositScheduleParams) (*DepositScheduleDto, error) {
	res, err := c.sendDepositSchedulesExternalControllerCreateDepositSchedule(ctx, request, params)
	return res, err
}

func (c *Client) sendDepositSchedulesExternalControllerCreateDepositSchedule(ctx context.Context, request *CreateDepositScheduleRequestDto, params DepositSchedulesExternalControllerCreateDepositScheduleParams) (res *DepositScheduleDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/deposit-schedules"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDepositSchedulesExternalControllerCreateDepositScheduleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-sa-jwt",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.XSaJwt))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesExternalControllerCreateDepositScheduleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesExternalControllerGetDepositScheduleByPersistentUuid invokes DepositSchedulesExternalController_getDepositScheduleByPersistentUuid operation.
//
// Endpoint get a DepositSchedule by persistent uuid.
//
// GET /external/v1/deposit-schedules/{persistentUuid}
func (c *Client) DepositSchedulesExternalControllerGetDepositScheduleByPersistentUuid(ctx context.Context, params DepositSchedulesExternalControllerGetDepositScheduleByPersistentUuidParams) (*DepositScheduleView, error) {
	res, err := c.sendDepositSchedulesExternalControllerGetDepositScheduleByPersistentUuid(ctx, params)
	return res, err
}

func (c *Client) sendDepositSchedulesExternalControllerGetDepositScheduleByPersistentUuid(ctx context.Context, params DepositSchedulesExternalControllerGetDepositScheduleByPersistentUuidParams) (res *DepositScheduleView, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/external/v1/deposit-schedules/"
	{
		// Encode "persistentUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "persistentUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PersistentUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-sa-jwt",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.XSaJwt))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesExternalControllerGetDepositScheduleByPersistentUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesExternalControllerGetDepositSchedules invokes DepositSchedulesExternalController_getDepositSchedules operation.
//
// Endpoint to get ACTIVE and IN_PROGRESS deposit schedules for customer.
//
// GET /external/v1/deposit-schedules
func (c *Client) DepositSchedulesExternalControllerGetDepositSchedules(ctx context.Context) ([]DepositScheduleView, error) {
	res, err := c.sendDepositSchedulesExternalControllerGetDepositSchedules(ctx)
	return res, err
}

func (c *Client) sendDepositSchedulesExternalControllerGetDepositSchedules(ctx context.Context) (res []DepositScheduleView, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/deposit-schedules"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, DepositSchedulesExternalControllerGetDepositSchedulesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesExternalControllerGetDepositSchedulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesExternalControllerSoftDeleteDepositSchedule invokes DepositSchedulesExternalController_softDeleteDepositSchedule operation.
//
// Endpoint removes a DepositSchedule for persistent uuid.
//
// DELETE /external/v1/deposit-schedules/{persistentUuid}
func (c *Client) DepositSchedulesExternalControllerSoftDeleteDepositSchedule(ctx context.Context, params DepositSchedulesExternalControllerSoftDeleteDepositScheduleParams) error {
	_, err := c.sendDepositSchedulesExternalControllerSoftDeleteDepositSchedule(ctx, params)
	return err
}

func (c *Client) sendDepositSchedulesExternalControllerSoftDeleteDepositSchedule(ctx context.Context, params DepositSchedulesExternalControllerSoftDeleteDepositScheduleParams) (res *DepositSchedulesExternalControllerSoftDeleteDepositScheduleNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/external/v1/deposit-schedules/"
	{
		// Encode "persistentUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "persistentUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PersistentUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-sa-jwt",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.XSaJwt))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesExternalControllerSoftDeleteDepositScheduleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFAST invokes DepositSchedulesExternalController_updateAllDepositSchedulesInCustomerBankToFAST operation.
//
// Endpoint to update all deposit schedules that are using the old SGDD bank to the new FAST bank for
// customer.
//
// POST /external/v1/deposit-schedules/fastify
func (c *Client) DepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFAST(ctx context.Context, request *FastifyDepositScheduleDto) ([]DepositScheduleView, error) {
	res, err := c.sendDepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFAST(ctx, request)
	return res, err
}

func (c *Client) sendDepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFAST(ctx context.Context, request *FastifyDepositScheduleDto) (res []DepositScheduleView, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/deposit-schedules/fastify"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFASTRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, DepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFASTOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesExternalControllerUpdateAllDepositSchedulesInCustomerBankToFASTResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesExternalControllerUpdateDepositSchedule invokes DepositSchedulesExternalController_updateDepositSchedule operation.
//
// Endpoint recreates a DepositSchedule for persistent uuid.
//
// PUT /external/v1/deposit-schedules/{persistentUuid}
func (c *Client) DepositSchedulesExternalControllerUpdateDepositSchedule(ctx context.Context, request *CreateDepositScheduleRequestDto, params DepositSchedulesExternalControllerUpdateDepositScheduleParams) (*DepositScheduleView, error) {
	res, err := c.sendDepositSchedulesExternalControllerUpdateDepositSchedule(ctx, request, params)
	return res, err
}

func (c *Client) sendDepositSchedulesExternalControllerUpdateDepositSchedule(ctx context.Context, request *CreateDepositScheduleRequestDto, params DepositSchedulesExternalControllerUpdateDepositScheduleParams) (res *DepositScheduleView, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/external/v1/deposit-schedules/"
	{
		// Encode "persistentUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "persistentUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PersistentUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDepositSchedulesExternalControllerUpdateDepositScheduleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-sa-jwt",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.XSaJwt))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesExternalControllerUpdateDepositScheduleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesInternalControllerCreateDepositSchedule invokes DepositSchedulesInternalController_createDepositSchedule operation.
//
// Endpoint to create a new DepositSchedule.
//
// POST /int/v1/deposit-schedules
func (c *Client) DepositSchedulesInternalControllerCreateDepositSchedule(ctx context.Context, request *CreateDepositScheduleDto) (*DepositScheduleDto, error) {
	res, err := c.sendDepositSchedulesInternalControllerCreateDepositSchedule(ctx, request)
	return res, err
}

func (c *Client) sendDepositSchedulesInternalControllerCreateDepositSchedule(ctx context.Context, request *CreateDepositScheduleDto) (res *DepositScheduleDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/int/v1/deposit-schedules"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDepositSchedulesInternalControllerCreateDepositScheduleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesInternalControllerCreateDepositScheduleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesInternalControllerFastify invokes DepositSchedulesInternalController_fastify operation.
//
// Endpoint to bulk migrate old SGDD deposit schedules to FAST.
//
// POST /int/v1/deposit-schedules/fastify
func (c *Client) DepositSchedulesInternalControllerFastify(ctx context.Context, request *FastifyDepositScheduleInternalDto) error {
	_, err := c.sendDepositSchedulesInternalControllerFastify(ctx, request)
	return err
}

func (c *Client) sendDepositSchedulesInternalControllerFastify(ctx context.Context, request *FastifyDepositScheduleInternalDto) (res *DepositSchedulesInternalControllerFastifyCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/int/v1/deposit-schedules/fastify"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDepositSchedulesInternalControllerFastifyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesInternalControllerFastifyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DepositSchedulesInternalControllerSoftDeleteDepositSchedule invokes DepositSchedulesInternalController_softDeleteDepositSchedule operation.
//
// Soft delete a deposit schedule.
//
// DELETE /int/v1/deposit-schedules
func (c *Client) DepositSchedulesInternalControllerSoftDeleteDepositSchedule(ctx context.Context, request *SoftDeleteDepositScheduleRequestDto) error {
	_, err := c.sendDepositSchedulesInternalControllerSoftDeleteDepositSchedule(ctx, request)
	return err
}

func (c *Client) sendDepositSchedulesInternalControllerSoftDeleteDepositSchedule(ctx context.Context, request *SoftDeleteDepositScheduleRequestDto) (res *DepositSchedulesInternalControllerSoftDeleteDepositScheduleNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/int/v1/deposit-schedules"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDepositSchedulesInternalControllerSoftDeleteDepositScheduleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDepositSchedulesInternalControllerSoftDeleteDepositScheduleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EddaCallbackExternalControllerCreationCallback invokes EddaCallbackExternalController_creationCallback operation.
//
// POST /external/edda/api/v1/edda/callback/creation
func (c *Client) EddaCallbackExternalControllerCreationCallback(ctx context.Context) error {
	_, err := c.sendEddaCallbackExternalControllerCreationCallback(ctx)
	return err
}

func (c *Client) sendEddaCallbackExternalControllerCreationCallback(ctx context.Context) (res *EddaCallbackExternalControllerCreationCallbackNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/edda/api/v1/edda/callback/creation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEddaCallbackExternalControllerCreationCallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EddaCallbackExternalControllerMandateCancellationCallback invokes EddaCallbackExternalController_mandateCancellationCallback operation.
//
// POST /external/edda/api/v1/edda/callback/cancellation
func (c *Client) EddaCallbackExternalControllerMandateCancellationCallback(ctx context.Context, request *CancellationCallbackDto) error {
	_, err := c.sendEddaCallbackExternalControllerMandateCancellationCallback(ctx, request)
	return err
}

func (c *Client) sendEddaCallbackExternalControllerMandateCancellationCallback(ctx context.Context, request *CancellationCallbackDto) (res *EddaCallbackExternalControllerMandateCancellationCallbackNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/edda/api/v1/edda/callback/cancellation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEddaCallbackExternalControllerMandateCancellationCallbackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEddaCallbackExternalControllerMandateCancellationCallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EddaCallbackExternalControllerSubmitResponseCallback invokes EddaCallbackExternalController_submitResponseCallback operation.
//
// POST /external/edda/api/v1/edda/submitResponse
func (c *Client) EddaCallbackExternalControllerSubmitResponseCallback(ctx context.Context) error {
	_, err := c.sendEddaCallbackExternalControllerSubmitResponseCallback(ctx)
	return err
}

func (c *Client) sendEddaCallbackExternalControllerSubmitResponseCallback(ctx context.Context) (res *EddaCallbackExternalControllerSubmitResponseCallbackNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/edda/api/v1/edda/submitResponse"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEddaCallbackExternalControllerSubmitResponseCallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FailedDepositSplitsExternalControllerGetFailedDepositSplitsForCustomer invokes FailedDepositSplitsExternalController_getFailedDepositSplitsForCustomer operation.
//
// Endpoint to get failed deposit splits for customer.
//
// GET /external/v1/failed-deposit-splits
func (c *Client) FailedDepositSplitsExternalControllerGetFailedDepositSplitsForCustomer(ctx context.Context) ([]FailedDepositSplitsForAccountDTO, error) {
	res, err := c.sendFailedDepositSplitsExternalControllerGetFailedDepositSplitsForCustomer(ctx)
	return res, err
}

func (c *Client) sendFailedDepositSplitsExternalControllerGetFailedDepositSplitsForCustomer(ctx context.Context) (res []FailedDepositSplitsForAccountDTO, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/failed-deposit-splits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, FailedDepositSplitsExternalControllerGetFailedDepositSplitsForCustomerOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFailedDepositSplitsExternalControllerGetFailedDepositSplitsForCustomerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FastExternalControllerDeleteCustomerBank invokes FastExternalController_deleteCustomerBank operation.
//
// Endpoint to delete bank by id.
//
// DELETE /external/v1/fast/customer-banks/{id}
func (c *Client) FastExternalControllerDeleteCustomerBank(ctx context.Context, params FastExternalControllerDeleteCustomerBankParams) (*CustomerBankDto, error) {
	res, err := c.sendFastExternalControllerDeleteCustomerBank(ctx, params)
	return res, err
}

func (c *Client) sendFastExternalControllerDeleteCustomerBank(ctx context.Context, params FastExternalControllerDeleteCustomerBankParams) (res *CustomerBankDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/external/v1/fast/customer-banks/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-sa-jwt",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.XSaJwt))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFastExternalControllerDeleteCustomerBankResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FastExternalControllerGetRetailBankList invokes FastExternalController_getRetailBankList operation.
//
// Endpoint to get all retail banks from ACME.
//
// GET /external/v1/fast/banks
func (c *Client) FastExternalControllerGetRetailBankList(ctx context.Context, params FastExternalControllerGetRetailBankListParams) error {
	_, err := c.sendFastExternalControllerGetRetailBankList(ctx, params)
	return err
}

func (c *Client) sendFastExternalControllerGetRetailBankList(ctx context.Context, params FastExternalControllerGetRetailBankListParams) (res *GetRetailBanksListResponse, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/fast/banks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-sa-jwt",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.XSaJwt))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFastExternalControllerGetRetailBankListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FastExternalControllerInitFASTMandateSetup invokes FastExternalController_initFASTMandateSetup operation.
//
// Endpoint to init mandate setup and return mandate url for user.
//
// POST /external/v1/fast/banks/init-mandate-setup
func (c *Client) FastExternalControllerInitFASTMandateSetup(ctx context.Context, request *InitMandateSetupRequestDTO, params FastExternalControllerInitFASTMandateSetupParams) error {
	_, err := c.sendFastExternalControllerInitFASTMandateSetup(ctx, request, params)
	return err
}

func (c *Client) sendFastExternalControllerInitFASTMandateSetup(ctx context.Context, request *InitMandateSetupRequestDTO, params FastExternalControllerInitFASTMandateSetupParams) (res *InitMandateSetupResultDTO, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/fast/banks/init-mandate-setup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeFastExternalControllerInitFASTMandateSetupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-sa-jwt",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.XSaJwt))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFastExternalControllerInitFASTMandateSetupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HealthControllerGetEddaHealth invokes HealthController_getEddaHealth operation.
//
// GET /external/edda/health
func (c *Client) HealthControllerGetEddaHealth(ctx context.Context) error {
	_, err := c.sendHealthControllerGetEddaHealth(ctx)
	return err
}

func (c *Client) sendHealthControllerGetEddaHealth(ctx context.Context) (res *HealthControllerGetEddaHealthOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/edda/health"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHealthControllerGetEddaHealthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HealthControllerGetExternalHealth invokes HealthController_getExternalHealth operation.
//
// Endpoint to check the health of the service for api-gateway.
//
// GET /external/health
func (c *Client) HealthControllerGetExternalHealth(ctx context.Context) error {
	_, err := c.sendHealthControllerGetExternalHealth(ctx)
	return err
}

func (c *Client) sendHealthControllerGetExternalHealth(ctx context.Context) (res *HealthControllerGetExternalHealthOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/health"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHealthControllerGetExternalHealthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HealthControllerGetHealth invokes HealthController_getHealth operation.
//
// Endpoint to check the health of the service for liveness probe.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /health
func (c *Client) HealthControllerGetHealth(ctx context.Context) error {
	_, err := c.sendHealthControllerGetHealth(ctx)
	return err
}

func (c *Client) sendHealthControllerGetHealth(ctx context.Context) (res *HealthControllerGetHealthOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHealthControllerGetHealthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IntergoalTransferRequestExternalControllerCreateIntergoalTransferRequest invokes IntergoalTransferRequestExternalController_createIntergoalTransferRequest operation.
//
// Starts IGTRequest Workflow.
//
// POST /external/v1/intergoal-transfer-request
func (c *Client) IntergoalTransferRequestExternalControllerCreateIntergoalTransferRequest(ctx context.Context, request *StartIGTRequestWorkflowExternalRequestDTO, params IntergoalTransferRequestExternalControllerCreateIntergoalTransferRequestParams) (*StartIGTRequestWorkflowSuccessResponseDTO, error) {
	res, err := c.sendIntergoalTransferRequestExternalControllerCreateIntergoalTransferRequest(ctx, request, params)
	return res, err
}

func (c *Client) sendIntergoalTransferRequestExternalControllerCreateIntergoalTransferRequest(ctx context.Context, request *StartIGTRequestWorkflowExternalRequestDTO, params IntergoalTransferRequestExternalControllerCreateIntergoalTransferRequestParams) (res *StartIGTRequestWorkflowSuccessResponseDTO, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/intergoal-transfer-request"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIntergoalTransferRequestExternalControllerCreateIntergoalTransferRequestRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "x-sa-jwt",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.XSaJwt))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIntergoalTransferRequestExternalControllerCreateIntergoalTransferRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IntergoalTransferRequestExternalControllerGetIntergoalTransfersDuration invokes IntergoalTransferRequestExternalController_getIntergoalTransfersDuration operation.
//
// Get IGT duration.
//
// GET /external/v1/intergoal-transfer-request/duration
func (c *Client) IntergoalTransferRequestExternalControllerGetIntergoalTransfersDuration(ctx context.Context, params IntergoalTransferRequestExternalControllerGetIntergoalTransfersDurationParams) error {
	_, err := c.sendIntergoalTransferRequestExternalControllerGetIntergoalTransfersDuration(ctx, params)
	return err
}

func (c *Client) sendIntergoalTransferRequestExternalControllerGetIntergoalTransfersDuration(ctx context.Context, params IntergoalTransferRequestExternalControllerGetIntergoalTransfersDurationParams) (res *IntergoalTransferRequestExternalControllerGetIntergoalTransfersDurationOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/intergoal-transfer-request/duration"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "fromGoalType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "fromGoalType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FromGoalType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "toGoalType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "toGoalType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ToGoalType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Region))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIntergoalTransferRequestExternalControllerGetIntergoalTransfersDurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IntergoalTransferRequestInternalControllerCancel invokes IntergoalTransferRequestInternalController_cancel operation.
//
// Cancels an Intergoal Transfer Request.
//
// POST /internal/v1/intergoal-transfer-request/{id}/cancel
func (c *Client) IntergoalTransferRequestInternalControllerCancel(ctx context.Context, request *CancelIntergoalTransferDTO, params IntergoalTransferRequestInternalControllerCancelParams) error {
	_, err := c.sendIntergoalTransferRequestInternalControllerCancel(ctx, request, params)
	return err
}

func (c *Client) sendIntergoalTransferRequestInternalControllerCancel(ctx context.Context, request *CancelIntergoalTransferDTO, params IntergoalTransferRequestInternalControllerCancelParams) (res *IntergoalTransferRequestInternalControllerCancelOK, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/internal/v1/intergoal-transfer-request/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIntergoalTransferRequestInternalControllerCancelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIntergoalTransferRequestInternalControllerCancelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IntergoalTransferRequestInternalControllerCreateIntergoalTransferRequest invokes IntergoalTransferRequestInternalController_createIntergoalTransferRequest operation.
//
// Starts IGTRequest Workflow.
//
// POST /internal/v1/intergoal-transfer-request
func (c *Client) IntergoalTransferRequestInternalControllerCreateIntergoalTransferRequest(ctx context.Context, request *StartIGTRequestWorkflowRequestDTO) (*StartIGTRequestWorkflowSuccessResponseDTO, error) {
	res, err := c.sendIntergoalTransferRequestInternalControllerCreateIntergoalTransferRequest(ctx, request)
	return res, err
}

func (c *Client) sendIntergoalTransferRequestInternalControllerCreateIntergoalTransferRequest(ctx context.Context, request *StartIGTRequestWorkflowRequestDTO) (res *StartIGTRequestWorkflowSuccessResponseDTO, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/intergoal-transfer-request"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeIntergoalTransferRequestInternalControllerCreateIntergoalTransferRequestRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIntergoalTransferRequestInternalControllerCreateIntergoalTransferRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IntergoalTransferRequestInternalControllerGetIGTSchedules invokes IntergoalTransferRequestInternalController_getIGTSchedules operation.
//
// Get all IGT schedules by userId.
//
// GET /internal/v1/intergoal-transfer-request/schedules
func (c *Client) IntergoalTransferRequestInternalControllerGetIGTSchedules(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIGTSchedulesParams) (IntergoalTransferRequestInternalControllerGetIGTSchedulesRes, error) {
	res, err := c.sendIntergoalTransferRequestInternalControllerGetIGTSchedules(ctx, params)
	return res, err
}

func (c *Client) sendIntergoalTransferRequestInternalControllerGetIGTSchedules(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIGTSchedulesParams) (res IntergoalTransferRequestInternalControllerGetIGTSchedulesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/intergoal-transfer-request/schedules"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "userId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "userId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIntergoalTransferRequestInternalControllerGetIGTSchedulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IntergoalTransferRequestInternalControllerGetIntergoalTransfersDuration invokes IntergoalTransferRequestInternalController_getIntergoalTransfersDuration operation.
//
// Get IGT duration.
//
// GET /internal/v1/intergoal-transfer-request/duration
func (c *Client) IntergoalTransferRequestInternalControllerGetIntergoalTransfersDuration(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIntergoalTransfersDurationParams) error {
	_, err := c.sendIntergoalTransferRequestInternalControllerGetIntergoalTransfersDuration(ctx, params)
	return err
}

func (c *Client) sendIntergoalTransferRequestInternalControllerGetIntergoalTransfersDuration(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIntergoalTransfersDurationParams) (res *IntergoalTransferRequestInternalControllerGetIntergoalTransfersDurationOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/intergoal-transfer-request/duration"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "fromGoalType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "fromGoalType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FromGoalType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "toGoalType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "toGoalType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ToGoalType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "region" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "region",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Region))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIntergoalTransferRequestInternalControllerGetIntergoalTransfersDurationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuid invokes IntergoalTransferRequestInternalController_getIntergoalTransfersRequestByAccountUuid operation.
//
// Get all IGT for an account.
//
// GET /internal/v1/intergoal-transfer-request
func (c *Client) IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuid(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidParams) (IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidRes, error) {
	res, err := c.sendIntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuid(ctx, params)
	return res, err
}

func (c *Client) sendIntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuid(ctx context.Context, params IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidParams) (res IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/intergoal-transfer-request"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "accountUuid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accountUuid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AccountUuid))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanExternalControllerCancelPaymentIntent invokes LeanExternalController_cancelPaymentIntent operation.
//
// Endpoint to cancel payment intent.
//
// POST /external/v1/lean/payment-intents/{paymentIntentId}/cancel
func (c *Client) LeanExternalControllerCancelPaymentIntent(ctx context.Context, request *LeanPaymentIntentCancelInputDto, params LeanExternalControllerCancelPaymentIntentParams) (*GetLeanCustomerDto, error) {
	res, err := c.sendLeanExternalControllerCancelPaymentIntent(ctx, request, params)
	return res, err
}

func (c *Client) sendLeanExternalControllerCancelPaymentIntent(ctx context.Context, request *LeanPaymentIntentCancelInputDto, params LeanExternalControllerCancelPaymentIntentParams) (res *GetLeanCustomerDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/external/v1/lean/payment-intents/"
	{
		// Encode "paymentIntentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "paymentIntentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PaymentIntentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLeanExternalControllerCancelPaymentIntentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, LeanExternalControllerCancelPaymentIntentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanExternalControllerCancelPaymentIntentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanExternalControllerCreateInstantPaymentIntent invokes LeanExternalController_createInstantPaymentIntent operation.
//
// Endpoint to create an instant payment intent.
//
// POST /external/v1/lean/payment-intents
func (c *Client) LeanExternalControllerCreateInstantPaymentIntent(ctx context.Context, request *LeanPaymentIntentInputDto) (*LeanPaymentIntentDto, error) {
	res, err := c.sendLeanExternalControllerCreateInstantPaymentIntent(ctx, request)
	return res, err
}

func (c *Client) sendLeanExternalControllerCreateInstantPaymentIntent(ctx context.Context, request *LeanPaymentIntentInputDto) (res *LeanPaymentIntentDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/lean/payment-intents"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLeanExternalControllerCreateInstantPaymentIntentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, LeanExternalControllerCreateInstantPaymentIntentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanExternalControllerCreateInstantPaymentIntentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanExternalControllerCreateLeanToken invokes LeanExternalController_createLeanToken operation.
//
// Endpoint to create Lean Token for account id.
//
// POST /external/v1/lean/token
func (c *Client) LeanExternalControllerCreateLeanToken(ctx context.Context) (*GetLeanTokenDto, error) {
	res, err := c.sendLeanExternalControllerCreateLeanToken(ctx)
	return res, err
}

func (c *Client) sendLeanExternalControllerCreateLeanToken(ctx context.Context) (res *GetLeanTokenDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/lean/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, LeanExternalControllerCreateLeanTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanExternalControllerCreateLeanTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanExternalControllerCreatePaymentIntentForSchedule invokes LeanExternalController_createPaymentIntentForSchedule operation.
//
// Endpoint to create a deposit request and payment intent for deposit schedule.
//
// POST /external/v1/lean/scheduled-payment-intents
func (c *Client) LeanExternalControllerCreatePaymentIntentForSchedule(ctx context.Context, request *LeanScheduledPaymentIntentInputDto) (*LeanPaymentIntentDto, error) {
	res, err := c.sendLeanExternalControllerCreatePaymentIntentForSchedule(ctx, request)
	return res, err
}

func (c *Client) sendLeanExternalControllerCreatePaymentIntentForSchedule(ctx context.Context, request *LeanScheduledPaymentIntentInputDto) (res *LeanPaymentIntentDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/lean/scheduled-payment-intents"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLeanExternalControllerCreatePaymentIntentForScheduleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, LeanExternalControllerCreatePaymentIntentForScheduleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanExternalControllerCreatePaymentIntentForScheduleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanExternalControllerGetBanksConnectStatus invokes LeanExternalController_getBanksConnectStatus operation.
//
// Get status of connecting to banks.
//
// GET /external/v1/lean/banks/connect-status
func (c *Client) LeanExternalControllerGetBanksConnectStatus(ctx context.Context, params LeanExternalControllerGetBanksConnectStatusParams) (*BanksConnectStatusResponseDto, error) {
	res, err := c.sendLeanExternalControllerGetBanksConnectStatus(ctx, params)
	return res, err
}

func (c *Client) sendLeanExternalControllerGetBanksConnectStatus(ctx context.Context, params LeanExternalControllerGetBanksConnectStatusParams) (res *BanksConnectStatusResponseDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/lean/banks/connect-status"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "bankIdentifier" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bankIdentifier",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.BankIdentifier))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, LeanExternalControllerGetBanksConnectStatusOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanExternalControllerGetBanksConnectStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanExternalControllerGetOrCreateLeanCustomer invokes LeanExternalController_getOrCreateLeanCustomer operation.
//
// Endpoint to get LeanCustomer for account id.
//
// POST /external/v1/lean/customers
func (c *Client) LeanExternalControllerGetOrCreateLeanCustomer(ctx context.Context) (*GetLeanCustomerDto, error) {
	res, err := c.sendLeanExternalControllerGetOrCreateLeanCustomer(ctx)
	return res, err
}

func (c *Client) sendLeanExternalControllerGetOrCreateLeanCustomer(ctx context.Context) (res *GetLeanCustomerDto, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/lean/customers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, LeanExternalControllerGetOrCreateLeanCustomerOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanExternalControllerGetOrCreateLeanCustomerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanInternalControllerGetLeanUserByAccountUuid invokes LeanInternalController_getLeanUserByAccountUuid operation.
//
// Endpoint to get LEAN customer.
//
// GET /internal/v1/lean/user/{accountUuid}
func (c *Client) LeanInternalControllerGetLeanUserByAccountUuid(ctx context.Context, params LeanInternalControllerGetLeanUserByAccountUuidParams) (*LeanCustomer, error) {
	res, err := c.sendLeanInternalControllerGetLeanUserByAccountUuid(ctx, params)
	return res, err
}

func (c *Client) sendLeanInternalControllerGetLeanUserByAccountUuid(ctx context.Context, params LeanInternalControllerGetLeanUserByAccountUuidParams) (res *LeanCustomer, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/internal/v1/lean/user/"
	{
		// Encode "accountUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "accountUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanInternalControllerGetLeanUserByAccountUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanInternalControllerTestConnectivity invokes LeanInternalController_testConnectivity operation.
//
// Endpoint to test connectivity with Lean.
//
// POST /internal/v1/lean/test-connectivity
func (c *Client) LeanInternalControllerTestConnectivity(ctx context.Context) error {
	_, err := c.sendLeanInternalControllerTestConnectivity(ctx)
	return err
}

func (c *Client) sendLeanInternalControllerTestConnectivity(ctx context.Context) (res *LeanInternalControllerTestConnectivityOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/lean/test-connectivity"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanInternalControllerTestConnectivityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LeanInternalControllerUnlinkBank invokes LeanInternalController_unlinkBank operation.
//
// Endpoint to unlink bank by customer request.
//
// POST /internal/v1/lean/banks/unlink
func (c *Client) LeanInternalControllerUnlinkBank(ctx context.Context, request *LeanUnlinkBankDto) error {
	_, err := c.sendLeanInternalControllerUnlinkBank(ctx, request)
	return err
}

func (c *Client) sendLeanInternalControllerUnlinkBank(ctx context.Context, request *LeanUnlinkBankDto) (res *LeanInternalControllerUnlinkBankOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/lean/banks/unlink"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLeanInternalControllerUnlinkBankRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLeanInternalControllerUnlinkBankResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LocalBanksControllerGetLocalBanks invokes LocalBanksController_getLocalBanks operation.
//
// GET /v1/local-banks
func (c *Client) LocalBanksControllerGetLocalBanks(ctx context.Context) error {
	_, err := c.sendLocalBanksControllerGetLocalBanks(ctx)
	return err
}

func (c *Client) sendLocalBanksControllerGetLocalBanks(ctx context.Context) (res *LocalBanksControllerGetLocalBanksOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/local-banks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLocalBanksControllerGetLocalBanksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MockAbsBankControllerFakeMandateCreationUrl invokes MockAbsBankController_fakeMandateCreationUrl operation.
//
// GET /v1/mock-bank/mandate-creation-url
func (c *Client) MockAbsBankControllerFakeMandateCreationUrl(ctx context.Context, params MockAbsBankControllerFakeMandateCreationUrlParams) error {
	_, err := c.sendMockAbsBankControllerFakeMandateCreationUrl(ctx, params)
	return err
}

func (c *Client) sendMockAbsBankControllerFakeMandateCreationUrl(ctx context.Context, params MockAbsBankControllerFakeMandateCreationUrlParams) (res *MockAbsBankControllerFakeMandateCreationUrlOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/mock-bank/mandate-creation-url"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "boDDARefNo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "boDDARefNo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.BoDDARefNo))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "applicantBankCode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "applicantBankCode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ApplicantBankCode))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMockAbsBankControllerFakeMandateCreationUrlResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovements invokes PortfoliosExternalControllerV1_getRecentAndInProgressAccountMoneyMovements operation.
//
// Endpoint to get money movement with timeline.
//
// GET /external/v1/portfolios/money-movements
func (c *Client) PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovementsParams) error {
	_, err := c.sendPortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovements(ctx, params)
	return err
}

func (c *Client) sendPortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovementsParams) (res *PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovementsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/portfolios/money-movements"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "includeFinishedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "includeFinishedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.IncludeFinishedFrom))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovementsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePortfoliosExternalControllerV1GetRecentAndInProgressAccountMoneyMovementsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2 invokes PortfoliosExternalControllerV2_getRecentAndInProgressAccountMoneyMovementsV2 operation.
//
// Endpoint to get money movement with timeline.
//
// GET /external/v2/portfolios/money-movements
func (c *Client) PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2(ctx context.Context, params PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2Params) error {
	_, err := c.sendPortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2(ctx, params)
	return err
}

func (c *Client) sendPortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2(ctx context.Context, params PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2Params) (res *PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2OK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v2/portfolios/money-movements"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "includeFinishedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "includeFinishedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.IncludeFinishedFrom))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2Operation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePortfoliosExternalControllerV2GetRecentAndInProgressAccountMoneyMovementsV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PortfoliosInternalControllerV1GetMoneyMovements invokes PortfoliosInternalControllerV1_getMoneyMovements operation.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /internal/v1/portfolios/{portfolioId}/money-movements
func (c *Client) PortfoliosInternalControllerV1GetMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV1GetMoneyMovementsParams) error {
	_, err := c.sendPortfoliosInternalControllerV1GetMoneyMovements(ctx, params)
	return err
}

func (c *Client) sendPortfoliosInternalControllerV1GetMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV1GetMoneyMovementsParams) (res *PortfoliosInternalControllerV1GetMoneyMovementsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/internal/v1/portfolios/"
	{
		// Encode "portfolioId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "portfolioId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PortfolioId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/money-movements"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePortfoliosInternalControllerV1GetMoneyMovementsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovements invokes PortfoliosInternalControllerV1_getRecentAndInProgressAccountMoneyMovements operation.
//
// Endpoint to get money movement with timeline for a given account.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /internal/v1/portfolios/money-movements
func (c *Client) PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovementsParams) error {
	_, err := c.sendPortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovements(ctx, params)
	return err
}

func (c *Client) sendPortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovementsParams) (res *PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovementsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/portfolios/money-movements"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "userId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "userId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "includeFinishedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "includeFinishedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.IncludeFinishedFrom))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovementsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePortfoliosInternalControllerV1GetRecentAndInProgressAccountMoneyMovementsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PortfoliosInternalControllerV2GetMoneyMovementsV2 invokes PortfoliosInternalControllerV2_getMoneyMovementsV2 operation.
//
// GET /internal/v2/portfolios/{portfolioId}/money-movements
func (c *Client) PortfoliosInternalControllerV2GetMoneyMovementsV2(ctx context.Context, params PortfoliosInternalControllerV2GetMoneyMovementsV2Params) error {
	_, err := c.sendPortfoliosInternalControllerV2GetMoneyMovementsV2(ctx, params)
	return err
}

func (c *Client) sendPortfoliosInternalControllerV2GetMoneyMovementsV2(ctx context.Context, params PortfoliosInternalControllerV2GetMoneyMovementsV2Params) (res *PortfoliosInternalControllerV2GetMoneyMovementsV2OK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/internal/v2/portfolios/"
	{
		// Encode "portfolioId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "portfolioId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PortfolioId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/money-movements"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "transferDirection" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "transferDirection",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TransferDirection.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePortfoliosInternalControllerV2GetMoneyMovementsV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovements invokes PortfoliosInternalControllerV2_getRecentAndInProgressAccountMoneyMovements operation.
//
// Endpoint to get money movement with timeline for a given account.
//
// GET /internal/v2/portfolios/money-movements
func (c *Client) PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovementsParams) error {
	_, err := c.sendPortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovements(ctx, params)
	return err
}

func (c *Client) sendPortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovements(ctx context.Context, params PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovementsParams) (res *PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovementsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v2/portfolios/money-movements"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "userId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "userId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "includeFinishedFrom" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "includeFinishedFrom",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.IncludeFinishedFrom))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, PortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovementsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePortfoliosInternalControllerV2GetRecentAndInProgressAccountMoneyMovementsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SrsInternalControllerGetSrsTransferRequestWithSubtransfers invokes SrsInternalController_getSrsTransferRequestWithSubtransfers operation.
//
// Endpoint to fetch SRS transfer requests and their sub transfers.
//
// GET /internal/v1/srs/requests/{transferRequestId}/subTransfers
func (c *Client) SrsInternalControllerGetSrsTransferRequestWithSubtransfers(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestWithSubtransfersParams) (*SrsTransferRequestSubtransfers, error) {
	res, err := c.sendSrsInternalControllerGetSrsTransferRequestWithSubtransfers(ctx, params)
	return res, err
}

func (c *Client) sendSrsInternalControllerGetSrsTransferRequestWithSubtransfers(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestWithSubtransfersParams) (res *SrsTransferRequestSubtransfers, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/internal/v1/srs/requests/"
	{
		// Encode "transferRequestId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "transferRequestId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TransferRequestId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subTransfers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSrsInternalControllerGetSrsTransferRequestWithSubtransfersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SrsInternalControllerGetSrsTransferRequests invokes SrsInternalController_getSrsTransferRequests operation.
//
// Endpoint to fetch SRS transfer requests.
//
// GET /internal/v1/srs/requests
func (c *Client) SrsInternalControllerGetSrsTransferRequests(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestsParams) ([]TransferRequest, error) {
	res, err := c.sendSrsInternalControllerGetSrsTransferRequests(ctx, params)
	return res, err
}

func (c *Client) sendSrsInternalControllerGetSrsTransferRequests(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestsParams) (res []TransferRequest, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/srs/requests"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Direction)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Status)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSrsInternalControllerGetSrsTransferRequestsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SrsInternalControllerGetSrsTransferRequestsWithSubTransfers invokes SrsInternalController_getSrsTransferRequestsWithSubTransfers operation.
//
// Endpoint to fetch SRS transfer requests and their sub transfers.
//
// GET /internal/v1/srs/subTransfers
func (c *Client) SrsInternalControllerGetSrsTransferRequestsWithSubTransfers(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestsWithSubTransfersParams) ([]SrsTransferRequestSubtransfers, error) {
	res, err := c.sendSrsInternalControllerGetSrsTransferRequestsWithSubTransfers(ctx, params)
	return res, err
}

func (c *Client) sendSrsInternalControllerGetSrsTransferRequestsWithSubTransfers(ctx context.Context, params SrsInternalControllerGetSrsTransferRequestsWithSubTransfersParams) (res []SrsTransferRequestSubtransfers, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/srs/subTransfers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Direction)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Status)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSrsInternalControllerGetSrsTransferRequestsWithSubTransfersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsExternalControllerGetWithdrawalById invokes WithdrawalsExternalController_getWithdrawalById operation.
//
// Retrieves a withdrawal record by its UUID.
//
// GET /external/v1/transactions/withdrawal/{uuid}
func (c *Client) WithdrawalsExternalControllerGetWithdrawalById(ctx context.Context, params WithdrawalsExternalControllerGetWithdrawalByIdParams) (WithdrawalsExternalControllerGetWithdrawalByIdRes, error) {
	res, err := c.sendWithdrawalsExternalControllerGetWithdrawalById(ctx, params)
	return res, err
}

func (c *Client) sendWithdrawalsExternalControllerGetWithdrawalById(ctx context.Context, params WithdrawalsExternalControllerGetWithdrawalByIdParams) (res WithdrawalsExternalControllerGetWithdrawalByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/external/v1/transactions/withdrawal/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, WithdrawalsExternalControllerGetWithdrawalByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsExternalControllerGetWithdrawalByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsExternalControllerListWithdrawalsByAccount invokes WithdrawalsExternalController_listWithdrawalsByAccount operation.
//
// Retrieves withdrawal records for a specific account with pagination support.
//
// GET /external/v1/transactions/withdrawal
func (c *Client) WithdrawalsExternalControllerListWithdrawalsByAccount(ctx context.Context, params WithdrawalsExternalControllerListWithdrawalsByAccountParams) (WithdrawalsExternalControllerListWithdrawalsByAccountRes, error) {
	res, err := c.sendWithdrawalsExternalControllerListWithdrawalsByAccount(ctx, params)
	return res, err
}

func (c *Client) sendWithdrawalsExternalControllerListWithdrawalsByAccount(ctx context.Context, params WithdrawalsExternalControllerListWithdrawalsByAccountParams) (res WithdrawalsExternalControllerListWithdrawalsByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/transactions/withdrawal"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "portfolioUuid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "portfolioUuid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PortfolioUuid.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, WithdrawalsExternalControllerListWithdrawalsByAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsExternalControllerListWithdrawalsByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsExternalControllerSubmitWithdrawalRequests invokes WithdrawalsExternalController_submitWithdrawalRequests operation.
//
// POST /external/v1/transactions/withdrawal/submit
func (c *Client) WithdrawalsExternalControllerSubmitWithdrawalRequests(ctx context.Context, request *ExternalSubmitWithdrawalRequestsInputDto) (*SubmitWithdrawalRequestsResponseDto, error) {
	res, err := c.sendWithdrawalsExternalControllerSubmitWithdrawalRequests(ctx, request)
	return res, err
}

func (c *Client) sendWithdrawalsExternalControllerSubmitWithdrawalRequests(ctx context.Context, request *ExternalSubmitWithdrawalRequestsInputDto) (res *SubmitWithdrawalRequestsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/external/v1/transactions/withdrawal/submit"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWithdrawalsExternalControllerSubmitWithdrawalRequestsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearer(ctx, WithdrawalsExternalControllerSubmitWithdrawalRequestsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Bearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsExternalControllerSubmitWithdrawalRequestsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsInternalControllerAllowedCurrencies invokes WithdrawalsInternalController_allowedCurrencies operation.
//
// GET /internal/v1/transactions/withdrawal/allowed-currencies/{userId}
func (c *Client) WithdrawalsInternalControllerAllowedCurrencies(ctx context.Context, params WithdrawalsInternalControllerAllowedCurrenciesParams) ([]string, error) {
	res, err := c.sendWithdrawalsInternalControllerAllowedCurrencies(ctx, params)
	return res, err
}

func (c *Client) sendWithdrawalsInternalControllerAllowedCurrencies(ctx context.Context, params WithdrawalsInternalControllerAllowedCurrenciesParams) (res []string, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/internal/v1/transactions/withdrawal/allowed-currencies/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "goalType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "goalType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.GoalType))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsInternalControllerAllowedCurrenciesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsInternalControllerBatchApproveFlaggedWithdrawals invokes WithdrawalsInternalController_batchApproveFlaggedWithdrawals operation.
//
// POST /internal/v1/transactions/withdrawal/batch-approve-flagged-withdrawals
func (c *Client) WithdrawalsInternalControllerBatchApproveFlaggedWithdrawals(ctx context.Context, request *BatchWithdrawalApprovalInputDto) (*BatchWithdrawalApprovalResponseDto, error) {
	res, err := c.sendWithdrawalsInternalControllerBatchApproveFlaggedWithdrawals(ctx, request)
	return res, err
}

func (c *Client) sendWithdrawalsInternalControllerBatchApproveFlaggedWithdrawals(ctx context.Context, request *BatchWithdrawalApprovalInputDto) (res *BatchWithdrawalApprovalResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/transactions/withdrawal/batch-approve-flagged-withdrawals"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWithdrawalsInternalControllerBatchApproveFlaggedWithdrawalsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsInternalControllerBatchApproveFlaggedWithdrawalsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsInternalControllerCreateWithdrawal invokes WithdrawalsInternalController_createWithdrawal operation.
//
// Creates a new withdrawal record with the provided details. This endpoint is just creating the
// entity (should only be called by withdrawal workflow).
//
// POST /internal/v1/transactions/withdrawal
func (c *Client) WithdrawalsInternalControllerCreateWithdrawal(ctx context.Context, request *CreateWithdrawalBodyInternalDTO) (WithdrawalsInternalControllerCreateWithdrawalRes, error) {
	res, err := c.sendWithdrawalsInternalControllerCreateWithdrawal(ctx, request)
	return res, err
}

func (c *Client) sendWithdrawalsInternalControllerCreateWithdrawal(ctx context.Context, request *CreateWithdrawalBodyInternalDTO) (res WithdrawalsInternalControllerCreateWithdrawalRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/transactions/withdrawal"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWithdrawalsInternalControllerCreateWithdrawalRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsInternalControllerCreateWithdrawalResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsInternalControllerGetWithdrawalById invokes WithdrawalsInternalController_getWithdrawalById operation.
//
// Retrieves a withdrawal record by its UUID.
//
// GET /internal/v1/transactions/withdrawal/{uuid}
func (c *Client) WithdrawalsInternalControllerGetWithdrawalById(ctx context.Context, params WithdrawalsInternalControllerGetWithdrawalByIdParams) (WithdrawalsInternalControllerGetWithdrawalByIdRes, error) {
	res, err := c.sendWithdrawalsInternalControllerGetWithdrawalById(ctx, params)
	return res, err
}

func (c *Client) sendWithdrawalsInternalControllerGetWithdrawalById(ctx context.Context, params WithdrawalsInternalControllerGetWithdrawalByIdParams) (res WithdrawalsInternalControllerGetWithdrawalByIdRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/internal/v1/transactions/withdrawal/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "accountUuid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accountUuid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AccountUuid.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsInternalControllerGetWithdrawalByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsInternalControllerListWithdrawalsByAccount invokes WithdrawalsInternalController_listWithdrawalsByAccount operation.
//
// Retrieves withdrawal records for a specific account with pagination support.
//
// GET /internal/v1/transactions/withdrawal
func (c *Client) WithdrawalsInternalControllerListWithdrawalsByAccount(ctx context.Context, params WithdrawalsInternalControllerListWithdrawalsByAccountParams) (WithdrawalsInternalControllerListWithdrawalsByAccountRes, error) {
	res, err := c.sendWithdrawalsInternalControllerListWithdrawalsByAccount(ctx, params)
	return res, err
}

func (c *Client) sendWithdrawalsInternalControllerListWithdrawalsByAccount(ctx context.Context, params WithdrawalsInternalControllerListWithdrawalsByAccountParams) (res WithdrawalsInternalControllerListWithdrawalsByAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/transactions/withdrawal"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "portfolioUuid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "portfolioUuid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PortfolioUuid.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "accountUuid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accountUuid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AccountUuid))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsInternalControllerListWithdrawalsByAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsInternalControllerSubmitWithdrawalRequests invokes WithdrawalsInternalController_submitWithdrawalRequests operation.
//
// POST /internal/v1/transactions/withdrawal/submit
func (c *Client) WithdrawalsInternalControllerSubmitWithdrawalRequests(ctx context.Context, request *InternalSubmitWithdrawalRequestsInputDto) (*SubmitWithdrawalRequestsResponseDto, error) {
	res, err := c.sendWithdrawalsInternalControllerSubmitWithdrawalRequests(ctx, request)
	return res, err
}

func (c *Client) sendWithdrawalsInternalControllerSubmitWithdrawalRequests(ctx context.Context, request *InternalSubmitWithdrawalRequestsInputDto) (res *SubmitWithdrawalRequestsResponseDto, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/transactions/withdrawal/submit"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWithdrawalsInternalControllerSubmitWithdrawalRequestsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsInternalControllerSubmitWithdrawalRequestsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawalsInternalControllerUpdateAMLStatus invokes WithdrawalsInternalController_updateAMLStatus operation.
//
// POST /internal/v1/transactions/withdrawal/update-aml-status
func (c *Client) WithdrawalsInternalControllerUpdateAMLStatus(ctx context.Context, request *UpdateWithdrawalAmlStatusDto) error {
	_, err := c.sendWithdrawalsInternalControllerUpdateAMLStatus(ctx, request)
	return err
}

func (c *Client) sendWithdrawalsInternalControllerUpdateAMLStatus(ctx context.Context, request *UpdateWithdrawalAmlStatusDto) (res *WithdrawalsInternalControllerUpdateAMLStatusOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/internal/v1/transactions/withdrawal/update-aml-status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWithdrawalsInternalControllerUpdateAMLStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawalsInternalControllerUpdateAMLStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

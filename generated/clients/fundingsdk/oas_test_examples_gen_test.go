// Code generated by ogen, DO NOT EDIT.

package fundingsdk

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAdminBankDto_EncodeDecode(t *testing.T) {
	var typ AdminBankDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AdminBankDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAnonymizePiiRequestDTO_EncodeDecode(t *testing.T) {
	var typ AnonymizePiiRequestDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AnonymizePiiRequestDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAnonymizePiiRequestDTOUser_EncodeDecode(t *testing.T) {
	var typ AnonymizePiiRequestDTOUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AnonymizePiiRequestDTOUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBankAccountDestination_EncodeDecode(t *testing.T) {
	var typ BankAccountDestination
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BankAccountDestination
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBankAccountSource_EncodeDecode(t *testing.T) {
	var typ BankAccountSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BankAccountSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBanksConnectStatusResponseDto_EncodeDecode(t *testing.T) {
	var typ BanksConnectStatusResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BanksConnectStatusResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBanksConnectStatusResponseDtoStatus_EncodeDecode(t *testing.T) {
	var typ BanksConnectStatusResponseDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BanksConnectStatusResponseDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestBanksConnectStatusResponseDtoStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"BANK_CREATED\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ BanksConnectStatusResponseDtoStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 BanksConnectStatusResponseDtoStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBatchWithdrawalApprovalInputDto_EncodeDecode(t *testing.T) {
	var typ BatchWithdrawalApprovalInputDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BatchWithdrawalApprovalInputDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBatchWithdrawalApprovalResponseDto_EncodeDecode(t *testing.T) {
	var typ BatchWithdrawalApprovalResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BatchWithdrawalApprovalResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCancellationCallbackDto_EncodeDecode(t *testing.T) {
	var typ CancellationCallbackDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CancellationCallbackDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDdCustomerBankDto_EncodeDecode(t *testing.T) {
	var typ CreateDdCustomerBankDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDdCustomerBankDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDepositScheduleDto_EncodeDecode(t *testing.T) {
	var typ CreateDepositScheduleDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDepositScheduleDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDepositScheduleDtoFrequency_EncodeDecode(t *testing.T) {
	var typ CreateDepositScheduleDtoFrequency
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDepositScheduleDtoFrequency
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDepositScheduleDtoRequestType_EncodeDecode(t *testing.T) {
	var typ CreateDepositScheduleDtoRequestType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDepositScheduleDtoRequestType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDepositScheduleDtoScheduleType_EncodeDecode(t *testing.T) {
	var typ CreateDepositScheduleDtoScheduleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDepositScheduleDtoScheduleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDepositScheduleRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateDepositScheduleRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDepositScheduleRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDepositScheduleRequestDtoFrequency_EncodeDecode(t *testing.T) {
	var typ CreateDepositScheduleRequestDtoFrequency
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDepositScheduleRequestDtoFrequency
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDepositScheduleRequestDtoRequestType_EncodeDecode(t *testing.T) {
	var typ CreateDepositScheduleRequestDtoRequestType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDepositScheduleRequestDtoRequestType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateDepositScheduleRequestDtoScheduleType_EncodeDecode(t *testing.T) {
	var typ CreateDepositScheduleRequestDtoScheduleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateDepositScheduleRequestDtoScheduleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateWhitelistedCustomerBankRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateWhitelistedCustomerBankRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateWhitelistedCustomerBankRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCustomerBankDto_EncodeDecode(t *testing.T) {
	var typ CustomerBankDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CustomerBankDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDepositRecordsInternalControllerGetDepositRecordsReq_EncodeDecode(t *testing.T) {
	var typ DepositRecordsInternalControllerGetDepositRecordsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositRecordsInternalControllerGetDepositRecordsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDepositScheduleDto_EncodeDecode(t *testing.T) {
	var typ DepositScheduleDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDepositScheduleDtoFrequency_EncodeDecode(t *testing.T) {
	var typ DepositScheduleDtoFrequency
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleDtoFrequency
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDepositScheduleDtoRequestType_EncodeDecode(t *testing.T) {
	var typ DepositScheduleDtoRequestType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleDtoRequestType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDepositScheduleDtoScheduleType_EncodeDecode(t *testing.T) {
	var typ DepositScheduleDtoScheduleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleDtoScheduleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDepositScheduleDtoStatus_EncodeDecode(t *testing.T) {
	var typ DepositScheduleDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDepositScheduleDtoStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"ACTIVE\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DepositScheduleDtoStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DepositScheduleDtoStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDepositScheduleView_EncodeDecode(t *testing.T) {
	var typ DepositScheduleView
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleView
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDepositScheduleViewFrequency_EncodeDecode(t *testing.T) {
	var typ DepositScheduleViewFrequency
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleViewFrequency
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDepositScheduleViewFrequency_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"MONTHLY\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DepositScheduleViewFrequency

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DepositScheduleViewFrequency
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDepositScheduleViewRequestType_EncodeDecode(t *testing.T) {
	var typ DepositScheduleViewRequestType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleViewRequestType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDepositScheduleViewRequestType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"LEAN\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DepositScheduleViewRequestType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DepositScheduleViewRequestType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDepositScheduleViewScheduleType_EncodeDecode(t *testing.T) {
	var typ DepositScheduleViewScheduleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleViewScheduleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDepositScheduleViewScheduleType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"RECURRING\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DepositScheduleViewScheduleType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DepositScheduleViewScheduleType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestDepositScheduleViewStatus_EncodeDecode(t *testing.T) {
	var typ DepositScheduleViewStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DepositScheduleViewStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestDepositScheduleViewStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"ACTIVE\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ DepositScheduleViewStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 DepositScheduleViewStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestExternalSubmitWithdrawalRequestsInputDto_EncodeDecode(t *testing.T) {
	var typ ExternalSubmitWithdrawalRequestsInputDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSubmitWithdrawalRequestsInputDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSubmitWithdrawalRequestsInputDtoComment_EncodeDecode(t *testing.T) {
	var typ ExternalSubmitWithdrawalRequestsInputDtoComment
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSubmitWithdrawalRequestsInputDtoComment
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestExternalSubmitWithdrawalRequestsInputDtoComment_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"No comment\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ExternalSubmitWithdrawalRequestsInputDtoComment

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ExternalSubmitWithdrawalRequestsInputDtoComment
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestFailedDepositSplitsForAccountDTO_EncodeDecode(t *testing.T) {
	var typ FailedDepositSplitsForAccountDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FailedDepositSplitsForAccountDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFastifyDepositScheduleDto_EncodeDecode(t *testing.T) {
	var typ FastifyDepositScheduleDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FastifyDepositScheduleDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFastifyDepositScheduleInternalDto_EncodeDecode(t *testing.T) {
	var typ FastifyDepositScheduleInternalDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FastifyDepositScheduleInternalDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFundDepositRecordDto_EncodeDecode(t *testing.T) {
	var typ FundDepositRecordDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FundDepositRecordDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetIGTByAccountUuidDTO_EncodeDecode(t *testing.T) {
	var typ GetIGTByAccountUuidDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetIGTByAccountUuidDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetIGTByAccountUuidDTOFundingSource_EncodeDecode(t *testing.T) {
	var typ GetIGTByAccountUuidDTOFundingSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetIGTByAccountUuidDTOFundingSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetIGTByAccountUuidDTORedemptionExtent_EncodeDecode(t *testing.T) {
	var typ GetIGTByAccountUuidDTORedemptionExtent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetIGTByAccountUuidDTORedemptionExtent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetIGTByAccountUuidDTORequestType_EncodeDecode(t *testing.T) {
	var typ GetIGTByAccountUuidDTORequestType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetIGTByAccountUuidDTORequestType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetIGTByAccountUuidDTOScheduleType_EncodeDecode(t *testing.T) {
	var typ GetIGTByAccountUuidDTOScheduleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetIGTByAccountUuidDTOScheduleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetIGTByAccountUuidDTOStatus_EncodeDecode(t *testing.T) {
	var typ GetIGTByAccountUuidDTOStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetIGTByAccountUuidDTOStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetLeanCustomerDto_EncodeDecode(t *testing.T) {
	var typ GetLeanCustomerDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetLeanCustomerDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetLeanTokenDto_EncodeDecode(t *testing.T) {
	var typ GetLeanTokenDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetLeanTokenDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRetailBanksListResponse_EncodeDecode(t *testing.T) {
	var typ GetRetailBanksListResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRetailBanksListResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInitMandateSetupRequestDTO_EncodeDecode(t *testing.T) {
	var typ InitMandateSetupRequestDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InitMandateSetupRequestDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInitMandateSetupResultDTO_EncodeDecode(t *testing.T) {
	var typ InitMandateSetupResultDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InitMandateSetupResultDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IntergoalTransferRequestInternalControllerGetIGTSchedulesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IntergoalTransferRequestInternalControllerGetIntergoalTransfersRequestByAccountUuidOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIntergoalTransferScheduleDTO_EncodeDecode(t *testing.T) {
	var typ IntergoalTransferScheduleDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IntergoalTransferScheduleDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSubmitWithdrawalRequestsInputDto_EncodeDecode(t *testing.T) {
	var typ InternalSubmitWithdrawalRequestsInputDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSubmitWithdrawalRequestsInputDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSubmitWithdrawalRequestsInputDtoWithdrawalType_EncodeDecode(t *testing.T) {
	var typ InternalSubmitWithdrawalRequestsInputDtoWithdrawalType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSubmitWithdrawalRequestsInputDtoWithdrawalType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeanPaymentIntentCancelInputDto_EncodeDecode(t *testing.T) {
	var typ LeanPaymentIntentCancelInputDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeanPaymentIntentCancelInputDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeanPaymentIntentDto_EncodeDecode(t *testing.T) {
	var typ LeanPaymentIntentDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeanPaymentIntentDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeanPaymentIntentInputDto_EncodeDecode(t *testing.T) {
	var typ LeanPaymentIntentInputDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeanPaymentIntentInputDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeanScheduledPaymentIntentInputDto_EncodeDecode(t *testing.T) {
	var typ LeanScheduledPaymentIntentInputDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeanScheduledPaymentIntentInputDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeanUnlinkBankDto_EncodeDecode(t *testing.T) {
	var typ LeanUnlinkBankDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeanUnlinkBankDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMoney_EncodeDecode(t *testing.T) {
	var typ Money
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Money
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOriginalTransferSourceAsDestination_EncodeDecode(t *testing.T) {
	var typ OriginalTransferSourceAsDestination
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OriginalTransferSourceAsDestination
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSoftDeleteDepositScheduleRequestDto_EncodeDecode(t *testing.T) {
	var typ SoftDeleteDepositScheduleRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SoftDeleteDepositScheduleRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSrsSubTransfer_EncodeDecode(t *testing.T) {
	var typ SrsSubTransfer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SrsSubTransfer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSrsSubTransferWithdrawalCostBasisForBank_EncodeDecode(t *testing.T) {
	var typ SrsSubTransferWithdrawalCostBasisForBank
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SrsSubTransferWithdrawalCostBasisForBank
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSrsTransferRequestSubtransfers_EncodeDecode(t *testing.T) {
	var typ SrsTransferRequestSubtransfers
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SrsTransferRequestSubtransfers
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStartIGTRequestWorkflowExternalRequestDTO_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowExternalRequestDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowExternalRequestDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStartIGTRequestWorkflowRequestDTO_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowRequestDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowRequestDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStartIGTRequestWorkflowRequestDTORequestType_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowRequestDTORequestType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowRequestDTORequestType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStartIGTRequestWorkflowRequestDTORequestType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"AUTO_PAYOUT_TRANSFER\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ StartIGTRequestWorkflowRequestDTORequestType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 StartIGTRequestWorkflowRequestDTORequestType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestStartIGTRequestWorkflowRequestDTORequestedAmount_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowRequestDTORequestedAmount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowRequestDTORequestedAmount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStartIGTRequestWorkflowRequestDTOScheduleType_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowRequestDTOScheduleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowRequestDTOScheduleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStartIGTRequestWorkflowRequestDTOScheduleType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"ONE_TIME\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ StartIGTRequestWorkflowRequestDTOScheduleType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 StartIGTRequestWorkflowRequestDTOScheduleType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestStartIGTRequestWorkflowSuccessResponseDTO_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowSuccessResponseDTO
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowSuccessResponseDTO
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStartIGTRequestWorkflowSuccessResponseDTOPostedAmount_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowSuccessResponseDTOPostedAmount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowSuccessResponseDTOPostedAmount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStartIGTRequestWorkflowSuccessResponseDTOPostedAmount_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"amount\":100,\"currency\":\"SGD\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ StartIGTRequestWorkflowSuccessResponseDTOPostedAmount

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 StartIGTRequestWorkflowSuccessResponseDTOPostedAmount
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestStartIGTRequestWorkflowSuccessResponseDTORedemptionExtent_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStartIGTRequestWorkflowSuccessResponseDTORedemptionExtent_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"PARTIAL\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 StartIGTRequestWorkflowSuccessResponseDTORedemptionExtent
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestStartIGTRequestWorkflowSuccessResponseDTORequestType_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowSuccessResponseDTORequestType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowSuccessResponseDTORequestType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStartIGTRequestWorkflowSuccessResponseDTORequestType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"REQUEST_BY_USER\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ StartIGTRequestWorkflowSuccessResponseDTORequestType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 StartIGTRequestWorkflowSuccessResponseDTORequestType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestStartIGTRequestWorkflowSuccessResponseDTORequestedAmount_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowSuccessResponseDTORequestedAmount
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowSuccessResponseDTORequestedAmount
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStartIGTRequestWorkflowSuccessResponseDTOScheduleType_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowSuccessResponseDTOScheduleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowSuccessResponseDTOScheduleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStartIGTRequestWorkflowSuccessResponseDTOScheduleType_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"ONE_TIME\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ StartIGTRequestWorkflowSuccessResponseDTOScheduleType

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 StartIGTRequestWorkflowSuccessResponseDTOScheduleType
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestStartIGTRequestWorkflowSuccessResponseDTOStatus_EncodeDecode(t *testing.T) {
	var typ StartIGTRequestWorkflowSuccessResponseDTOStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StartIGTRequestWorkflowSuccessResponseDTOStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestStartIGTRequestWorkflowSuccessResponseDTOStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"PENDING\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ StartIGTRequestWorkflowSuccessResponseDTOStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 StartIGTRequestWorkflowSuccessResponseDTOStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSubmitWithdrawalRequestsResponseDto_EncodeDecode(t *testing.T) {
	var typ SubmitWithdrawalRequestsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubmitWithdrawalRequestsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThresholdAmendmentDto_EncodeDecode(t *testing.T) {
	var typ ThresholdAmendmentDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThresholdAmendmentDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferRequest_EncodeDecode(t *testing.T) {
	var typ TransferRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferRequestDestinationType_EncodeDecode(t *testing.T) {
	var typ TransferRequestDestinationType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferRequestDestinationType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransferRequestTo_EncodeDecode(t *testing.T) {
	var typ TransferRequestTo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransferRequestTo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateWithdrawalAmlStatusDto_EncodeDecode(t *testing.T) {
	var typ UpdateWithdrawalAmlStatusDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateWithdrawalAmlStatusDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWithdrawalRequestDto_EncodeDecode(t *testing.T) {
	var typ WithdrawalRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WithdrawalRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
